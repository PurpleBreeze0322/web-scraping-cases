{"url_object_id": "4982221dc7233a7fb52e97b15b7f65e8", "title": "IT 职场新人碰到的几个常见误区", "create_date": "2018/03/29", "url": "http://blog.jobbole.com/112038/", "front_image_url": ["http://wx2.sinaimg.cn/large/7cc829d3gy1fptsk9tvx8j20go0b441z.jpg"], "praise_nums": 2, "fav_nums": 0, "comment_nums": "  评论", "content": "自己工作 10+ 年了，大概 5 年前从技术转管理后，多少还是发现一些职场新人职业发展的问题。\n表现惊艳的新人肯定有，这种人往往在学校里面或者进入职场后就养成了一些非常良好的做事方式和工作习惯，工作效率高，产出多，甚至很短时间内就可以带新人，年度最佳新人当之无愧。\n然而表现不到位的似乎更多一些，这些员工工作时间短（比如说应届毕业生或者不到两年）尤其性格内向的往往容易掉入错误泥潭，无法自拔，而这些错误的行为会对未来的发展造成非常负面的影响，从而导致职场发展往失败的道路上越走越远。\n我分别从以下角度来阐述一下，\n这种员工大多比较内向或者性情有点高冷，须不知三人行，必有我师。多向同事学习，互通有无，对自己以后的发展有百利而无一害。有导师制或者老员工带，情况或许会有所改善，但如果内因没有改变，最终效果依旧不容乐观。\n技术开发工作中遇到一些技术难题非常正常，当然独立思考固然可贵，但是公司项目往往有一定的时间限制，优先解决问题永远放在第一位，而不是一个人在那里苦苦挣扎和搜索解决方案。如果时间压力不大，多思考一下也未尝不可。考虑到交付压力，这个时候就需要积极和同事，技术经理沟通，寻找解决思路，通常情况下，积极的沟通好过自己的单打独斗。也许同事或者老板的一句话，就应了那据古诗，山重水复疑无路，柳暗花明又一村。与此同时也和同事建立了更好的友谊，在老板心里也留下了做事有方法的好印象。\n这种情况其实在职场中多见不仅是初级程序员，甚至工作五年以上的程序员也有类似的问题，不是自己的事情不闻不问，而且危害更大。\n公司项目往往大而全，如果仅仅专注自己的那个角落，那么永远都是只见树木，不见森林。\n我相信没有老板会介意下面的程序员多承担一些责任，多做一些事情，最后给项目组多一些产出。\n既然老板不介意，那么就应该大胆的跳出自己的职责范围，多看看公司的其他项目，丰富自己的行业知识。\n职责外的事情，帮的上的不要躲避,，努力承担更多的东西。帮助别人就是提高自己，教学相长就是这个意思。况且你这次帮了别人，下次你的项目紧或者遇到技术难题了，受助之人肯定投桃报李，这样就形成了良性互助氛围，整个项目组的产出也同步提升了。\n一般来说，公司要提升一个人，最好的策略就是先让候选人做一些将来职位才需要做的事情。做的好，理所当然就要提拔。做的不好，则可以提前发现该员工的问题，暂缓提拔，需要多考察一段时间。这样的试错成本毫无疑问是最低的。\n这里其实谈到了整个IT行业的问题，技术发展太快了。主要还是一个持续提升竞争力的一个话题。\n今天还是桌面开发，明天web开发就成为主流。\n好不容易掌握了关系型数据库，No-SQL成为主流。\n费了九牛二虎之力，熟练掌握Java, C#等静态语言，发现动态语言GO, Python成为云计算，机器学习的标配。\n移动开发昨天还是Object-C, Java, 今天就变成Swift, Kotlin。\n \n当然这里不是说让大家紧跟潮流，扼住时尚。那样做除了疲于奔命，累死在工作台，没有其他的结果。\n其实只要选择一个方向，纵深学习和积累，必有所成。\n比如说，你熟悉 Java, 那么学习 Kotlin 绝对驾轻就熟。\n你有扎实的关系型数据库基础，那么掌握 MangoDB 肯定是件轻而易举的事情。\n编成思想和解决问题的思路都是相通的，平时的学习和工作中要善于思考，举一反三。并且做到与时俱进，及时更新自己的知识库和技能属性，保持良好的市场竞争力。\n做完事情后多思考，怎样做得更好，站在更好的要求上看问题.\n我举两个实际案例，\n作者本人就犯过类似的错误，幡然醒悟的时候，三年时间已经过去了。\n程序员的职业生涯里面最初的三年其实是一个非常重要的打磨和规划时期，如果在迷茫中度过，那么事后想起肯定会扼腕叹息，奈何流水已经东去，再无复返之理。\n有目标，而没有具体的计划，那么就是一个愿景而已。\n建议不管是初级还是高级程序员，都应该积极向前辈或者直属老板沟通，看看他们有没有值得借鉴的规划和建议。\n职场大忌就是被动等待命运的安排，作者本人也是在职业生涯初期等待老板来帮我规划未来，到现在为止，十年过去了，也没有等到。。。\n所以老板不会主动帮助你规划未来，最重要的事情还是自己对自身的要求和期望。\n \n这也是一个非常好的话题，很多人都没有想明白，甚至包括一些工作十年之久的程序员。\n想明白这一点，工作积极性明显就会好太多。自我驱动, 让工作更加有趣和有意义。\n国内知名的互联网公司大老板说过一句话，非常值得深思。\n“我每年付你20万，五年也就是100万。如果你在这里混日子，那么最后吃亏的肯定是你。你的五年青春就只值100万吗？”\n所以职场新人的主人翁意识一定要加强，你要持续提升自己的能力，持续强化自己创造价值的能力。\n举个例子，比如说现在公司支付你20万每年，那么你应该有目标能给公司带来远超过20万的收益，多多益善。\n你有这个能力，公司肯定也会对你相应回报。如果公司不给你升职加薪，那么一走了之，潇洒痛快。优质的人才从来都是抢着要。\n这点倒是因人而异，不可强求。这个话题其实有点广义。\n如果你在某个方向做的非常好，而且回报也不错，那么不愿意涉足其他领域也无可厚非。\n这个世界唯一不变的东西就是世界一直在改变。今天还有的岗位，明天也许就要消失。世界要抛弃你，都不会打一声招呼。\n又比如说，你现在用的技术在日常项目中都刚好够用，那么从改善用户体验和使用更加主流的技术角度看，是不是应该要尝试一些新的东西，同时也刷新了自己的技术栈，一举两得，何乐而不为呢？\n最后再简单小结一下，职场新人需要做的就是从小事做起，学会吃亏，以结果为目标导向，日常工作中积极和同事，老板沟通。\n工作中要善于总结方法，经常更新问题的思考模式，对职业负责，对目标负责，对自己负责，脚踏实地，主动找事情做，而不是被动等事情来找你。\n相信职场新人如果能成功避开上面说的几个误区，那么在职业发展道路上就可以少走一些弯路，少犯一些错误，从而更快地实现自己的小目标。", "tags": "职场,职场", "front_image_path": "full/031407902bdeff19a2af7d3163aefed119d82c52.jpg"}
{"url_object_id": "1401d80b943d81d3493c295bfe34a3ab", "title": "Linux 新用户？来试试这 8 款重要的软件", "create_date": "2018/03/21", "url": "http://blog.jobbole.com/113775/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "praise_nums": 1, "fav_nums": 0, "comment_nums": "  评论", "content": "即便您不是计算机的新手，刚接触 Linux 时，通常都会面临选择使用应用软件的问题。在数百万 Linux 应用程序中，做起选择来并不轻松。本文中，您将能发现八个重要的 Linux 应用，帮助您快速选择应用程序。\n下面这些应用程序大多不是 Linux 独有的。如果有过使用 Windows/Mac 的经验，您很可能会熟悉其中一些软件。根据兴趣和需求，下面的程序可能不全符合您的要求，但是在我看来，清单里大多数甚至全部的软件，对于新用户开启 Linux 之旅都是有帮助的。\n : \n几乎不会不需要使用网页浏览器的用户。您可以看到陈旧的 Linux 发行版几乎都会附带 Firefox（火狐浏览器）或者其他 \n，关于浏览器，强烈建议您尝试 \n。它是谷歌浏览器的开源版。Chromium 的主要优点是速度和安全性。它同样拥有大量的附加组件。\n 是一个开源办公套件，其包括文字处理（Writer）、电子表格（Calc）、演示（Impress）、数据库（Base）、公式编辑器（Math）、矢量图和流程图（Draw）应用程序。它与 Microsoft Office 文档兼容，如果其基本功能不能满足需求，您可以使用 \n。\nLibreOffice 显然是 Linux 应用中至关重要的一员，如果您使用 Linux 的计算机，安装它是有必要的。\n 是一款非常强大的开源图片处理程序，它类似于 Photoshop。通过 GIMP，您可以编辑或是创建用于 Web 或是打印的光栅图（位图）。如果您对专业的图片处理没有概念，Linux 自然提供有更简单的图像编辑器，GIMP 看上去可能会复杂一点。GIMP 并不单纯提供图片裁剪和大小调整，它更覆盖了图层、滤镜、遮罩、路径和其他一些高级功能。\n 也许就是最好的影音播放器了。它是跨平台的，所以您可能在 Windows 上也听说过它。VLC 最特殊的地方是其拥有大量解码器（并不是所有的解码器都开放源代码），所以它几乎可以播放所有的影音文件。\n 完全是关于通讯的。您可以借助它使用 Google talk、Facebook chat、Yahoo、ICQ 和 XMPP。它是用于音视频通话（包括电话会议），桌面流desktop streaming和群组聊天的多用户工具。会话会被加密。Jistsy 同样能帮助您传输文件或记录电话。\n 是一款基于 Debian 系统发行版的另一款应用程序安装程序。并不是所有基于 Debian 的 Linux 都安装有它，如果您使用基于 Debian 的 Linux 操作系统没有预装，也许您可以试一试。Synaptic 是一款用于添加或移除系统应用的 GUI 工具，甚至相对于许多发行版默认安装的 \n ，经验丰富的 Linux 用户更亲睐于 Sunaptic。\n : \n 能支持您在计算机上运行虚拟机。当您想在当前 Linux 发行版上安装其他发行版或操作系统时，使用虚拟机会方便许多。您同样可以通过它运行 Windows 应用程序，性能可能会稍弱，但是如果您有一台强大的计算机，就不会那么糟。\n对于 Linux 的新用户来说，一款纸牌游戏并不是刚需，但是它真的太有趣了。当您进入这款纸牌游戏，您会发现，这是一款极好的纸牌游戏包。\n 是 Linux 标志性的应用程序，原因是 – 它涵盖超过八十种纸牌游戏，包括流行的 Klondike、Bakers Dozen、Camelot 等等，作为预警 – 它是会上瘾的，您可能会花很长时间沉迷于此！\n根据您所使用的发行版，这些软件会有不同的安装方法。但是大多数都可以通过您使用的发行版中的包管理器安装使用，甚至它们可能会预装在您的发行版上。安装并且尝试它们想必是最好的，如果不合您的胃口，您可以轻松地删除它们。\n ", "tags": "IT技术,Linux", "front_image_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg"}
{"url_object_id": "86a8795768a1192f6a4d22bbb49ab0d7", "title": "刚开始学编程？这几款小工具能让你事半功倍", "create_date": "2018/03/26", "url": "http://blog.jobbole.com/113785/", "front_image_url": ["https://pic.36krcnd.com/201803/10141844/8fkz2ekh01zhphjt.jpeg!1200"], "praise_nums": 1, "fav_nums": 5, "comment_nums": 1, "content": "科技行业里，可供人们使用的工具成百上千，你要怎么知道用哪一种上手最合适呢？\n拿最近刚进入编程这行的人来说吧，大量的工具信息堆砌过来其实毫无益处，反而会无从下手。我发现在自己的开发过程中，很多安装的扩展工具不仅没有真正起到助益作用，反而常常妨碍了正常的开发工作。\n我不是专家，不过随着时间的推移，我还是编制了一份工具清单，这些工具已经证明对我非常有用。如果你刚刚开始学习怎么编程的话，这个清单能给你提供一些指导。如果你是个经验丰富的开发人员，也希望你能从中学到一些新的东西。\n我将把这篇文章分为Chrome扩展程序和VS代码扩展扩展程序两部分。我知道还有其他的浏览器和文本编辑器，但是我想你当然只能在你能找到的工具里选择，所以还是别因为个人喜好而引起一场宗教般的争论。\n请随便选。\n现在设我是一位web开发人员，以Chrome为阵地。下面是一些能让我少花点时间的工具：\nVisual Studio Code是我写代码时的不二之选。\n每个人都有他自己喜欢的文本编辑器，我也不例外。不过，我还是想把这些扩展程序介绍给你，而它们对你所使用的大多数编辑器都适用。看看我最喜欢的扩展程序有哪些：\n你肯定也有自己中意的工具，这些工具对你的开发工作来说是必不可少的。也希望我上面提到的一些工具能够提高你的工作效率。\n但是千万不要落入贪多不烂的陷阱，因为它可能耗费很多时间。\n希望你能在评论区留下你最喜欢的工具，这样我们就可以共同进步了。", "tags": "IT技术,Web前端,编程", "front_image_path": "full/4f40ac43ac01e64e0f4b96cceb82a2b2bd8898a3.jpg"}
{"url_object_id": "d750eaa333832623ef22835422172102", "title": "如何在 Linux 上安装应用程序", "create_date": "2018/03/27", "url": "http://blog.jobbole.com/113793/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "praise_nums": 1, "fav_nums": 1, "comment_nums": 1, "content": "如何在 Linux 上安装应用程序？因为有许多操作系统，这个问题不止有一个答案。应用程序可以可以来自许多来源 —— 几乎不可能数的清，并且每个开发团队都可以以他们认为最好的方式提供软件。知道如何安装你所得到的软件是成为操作系统高级用户的一部分。\n十多年来，Linux 已经在使用软件库来分发软件。在这种情况下，“仓库”是一个托管可安装软件包的公共服务器。Linux 发行版提供了一条命令，以及该命令的图形界面，用于从服务器获取软件并将其安装到你的计算机。这是一个非常简单的概念，它已经成为所有主流手机操作系统的模式，最近，该模式也成为了两大闭源计算机操作系统的“应用商店”。\n从软件仓库安装是在 Linux 上安装应用程序的主要方法，它应该是你寻找想要安装的任何应用程序的首选地方。\n从软件仓库安装，通常需要一个命令，如：\n实际使用的命令取决于你所使用的 Linux 发行版。Fedora 使用 \n，OpenSUSE 使用 \n，Debian 和 Ubuntu 使用 \n，Slackware 使用 \n，FreeBSD 使用 \n，而基于 lllumos 的 Openlndiana 使用 \n。无论你使用什么，该命令通常要搜索你想要安装应用程序的正确名称，因为有时候你认为的软件名称不是它官方或独有的名称：\n一旦你找到要安装的软件包的名称后，使用 \n 子命令执行实际的下载和自动安装：\n有关从软件仓库安装的具体信息，请参阅你的 Linux 发行版的文档。\n图形工具通常也是如此。搜索你认为你想要的，然后安装它。\n与底层命令一样，图形安装程序的名称取决于你正在运行的 Linux 发行版。相关的应用程序通常使用“软件（software）”或“包（package）”等关键字进行标记，因此请在你的启动项或菜单中搜索这些词汇，然后你将找到所需的内容。 由于开源全由用户来选择，所以如果你不喜欢你的发行版提供的图形用户界面（GUI），那么你可以选择安装替代品。 你知道该如何做到这一点。\n你的 Linux 发行版为其打包的软件提供了标准仓库，通常也有额外的仓库。例如，\n 服务于 Red Hat Enterprise Linux 和 CentOS，\n 服务于 Fedora，Ubuntu 有各种级别的支持以及个人包存档（PPA），\n 为 OpenSUSE 提供额外的软件以及 \n 为 Slackware 提供社区构建脚本。\n默认情况下，你的 Linux 操作系统设置为只查看其官方仓库，因此如果你想使用其他软件集合，则必须自己添加额外库。你通常可以像安装软件包一样安装仓库。实际上，当你安装例如 \n 视频聊天，\n web 浏览器，谷歌浏览器等许多软件时，你的实际安装是访问他们的私有仓库，从中将最新版本的应用程序安装到你的机器上。\n你还可以通过编辑文本文件将仓库手动添加到你的软件包管理器的配置目录，或者运行命令来添加添加仓库。像往常一样，你使用的确切命令取决于 Linux 发行版本。例如，这是一个 \n 命令，它将一个仓库添加到系统中：\n仓库模型非常流行，因为它提供了用户（你）和开发人员之间的链接。重要更新发布之后，系统会提示你接受更新，并且你可以从一个集中位置接受所有更新。\n然而，有时候一个软件包还没有放到仓库中时。这些安装包有几种形式。\n有时候，开发人员会以通用的 Linux 打包格式分发软件，例如 RPM、DEB 或较新但非常流行的 FlatPak 或 Snap 格式。你不是访问仓库下载的，你只是得到了这个包。\n例如，视频编辑器 \n 为 APT 用户提供了一个 \n 文件，RPM 用户提供了 \n 文件。当你想要更新时，可以到网站下载最新的适合的文件。\n这些一次性软件包可以使用从仓库进行安装时所用的一样的工具进行安装。如果双击下载的软件包，图形安装程序将启动并逐步完成安装过程。\n或者，你可以从终端进行安装。这里的区别在于你从互联网下载的独立包文件不是来自仓库。这是一个“本地”安装，这意味着你的软件安装包不需要下载来安装。大多数软件包管理器都是透明处理的：\n在某些情况下，你需要采取额外的步骤才能使应用程序运行，因此请仔细阅读有关你正在安装软件的文档。\n一些开发人员以几种通用格式发布他们的包。常见的扩展名包括 \n 和 \n。NVIDIA 显卡驱动程序、像 Nuke 和 Mari 这样的 Foundry visual FX 软件包以及来自 \n 的许多非 DRM 游戏都是用这种安装程序。（LCTT 译注：DRM 是数字版权管理。）\n这种安装模式依赖于开发人员提供安装“向导”。一些安装程序是图形化的，而另一些只是在终端中运行。\n有两种方式来运行这些类型的安装程序。\n1、 你可以直接从终端运行安装程序：\n2、 另外，你可以通过标记其为可执行文件来运行它。要标记为安装程序可执行文件，右键单击它的图标并选择其属性。\n一旦你允许其运行，双击图标就可以安装了。\n对于其余的安装程序，只需要按照屏幕上的说明进行操作。\nAppImage 格式对于 Linux 相对来说比较新，尽管它的概念是基于 NeXT 和 Rox 的。这个想法很简单：运行应用程序所需的一切都应该放在一个目录中，然后该目录被视为一个“应用程序”。要运行该应用程序，只需双击该图标即可运行。不需要也要不应该把应用程序安装在传统意义的地方；它从你在硬盘上的任何地方运行都行。\n尽管它可以作为独立应用运行，但 AppImage 通常提供一些系统集成。\n如果你接受此条件，则将一个本地的 \n 文件安装到你的主目录。\n 文件是 Linux 桌面的应用程序菜单和 mimetype 系统使用的一个小配置文件。实质上，只是将桌面配置文件放置在主目录的应用程序列表中“安装”应用程序，而不实际安装它。你获得了安装某些东西的所有好处，以及能够在本地运行某些东西的好处，即“便携式应用程序”。\n有时，开发人员只是编译一个应用程序，然后将结果发布到下载中，没有安装脚本，也没有打包。通常，这意味着你下载了一个 TAR 文件，然后 \n，然后双击可执行文件（通常是你下载软件的名称）。\n当使用这种软件方式交付时，你可以将它放在你下载的地方，当你需要它时，你可以手动启动它，或者你可以自己进行快速但是麻烦的安装。这包括两个简单的步骤：\n如果你只是为自己安装应用程序，那么传统上会在你的主目录中放个 \n （“二进制文件binary” 的简称）目录作为本地安装的应用程序和脚本的存储位置。如果你的系统上有其他用户需要访问这些应用程序，传统上将二进制文件放置在 \n 中。最后，这取决于你存储应用程序的位置。\n下载通常以带版本名称的目录进行，如 \n 或者 \n。由于假设你将在某个时候更新应用程序，因此将版本号删除或创建目录的符号链接是个不错的主意。这样，即使你更新应用程序本身，为应用程序创建的启动程序也可以保持不变。\n要创建一个 \n 启动文件，打开一个文本编辑器并创建一个名为 \n 的文件。\n 由 \n 定义。下面是一个简单的启动器，用于一个名为 Twine 的游戏开发 IDE，安装在系统范围的 \n 目录中：\n棘手的一行是 \n 行。它必须包含一个有效的命令来启动应用程序。通常，它只是你下载的东西的完整路径，但在某些情况下，它更复杂一些。例如，Java 应用程序可能需要作为 Java 自身的参数启动。\n有时，一个项目包含一个可以运行的包装脚本，这样你就不必找出正确的命令：\n在这个 Twine 例子中，没有与该下载的软件捆绑的图标，因此示例 \n 文件指定了 KDE 桌面附带的通用游戏图标。你可以使用类似的解决方法，但如果你更具艺术性，可以创建自己的图标，或者可以在 Internet 上搜索一个好的图标。只要 \n 行指向一个有效的 PNG 或 SVG 文件，你的应用程序就会以该图标为代表。\n示例脚本还将应用程序类别主要设置为 Development，因此在 KDE、GNOME 和大多数其他应用程序菜单中，Twine 出现在开发类别下。\n为了让这个例子出现在应用程序菜单中，把 \n 文件放这到两个地方之一：\n现在，该应用程序已安装，因为它需要与系统的其他部分集成。\n最后，还有真正的通用格式安装格式：源代码。从源代码编译应用程序是学习如何构建应用程序，如何与系统交互以及如何定制应用程序的好方法。尽管如此，它绝不是一个点击按钮式过程。它需要一个构建环境，通常需要安装依赖库和头文件，有时还要进行一些调试。\n要了解更多关于从源代码编译的内容，请阅读\n。\n有些人认为安装软件是一个神奇的过程，只有开发人员理解，或者他们认为它“激活”了应用程序，就好像二进制可执行文件在“安装”之前无效。学习许多不同的安装方法会告诉你安装实际上只是“将文件从一个地方复制到系统中适当位置”的简写。 没有什么神秘的。只要你去了解每次安装，不是期望应该如何发生，并且寻找开发者为安装过程设置了什么，那么通常很容易，即使它与你的习惯不同。\n重要的是安装器要诚实于你。 如果你遇到未经你的同意尝试安装其他软件的安装程序（或者它可能会以混淆或误导的方式请求同意），或者尝试在没有明显原因的情况下对系统执行检查，则不要继续安装。\n好的软件是灵活的、诚实的、开放的。 现在你知道如何在你的计算机上获得好软件了。\n ", "tags": "IT技术,Linux", "front_image_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg"}
{"url_object_id": "ab0322e9007276c76fe370fbf4a95a33", "title": "Linux 中的“大内存页”（hugepage）是个什么？", "create_date": "2018/03/24", "url": "http://blog.jobbole.com/113782/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "praise_nums": 1, "fav_nums": 1, "comment_nums": "  评论", "content": "本文中我们会详细介绍大内存页huge page，让你能够回答：Linux 中的“大内存页”是什么？在 RHEL6、RHEL7、Ubuntu 等 Linux 中，如何启用/禁用“大内存页”？如何查看“大内存页”的当前值？\n首先让我们从“大内存页”的基础知识开始讲起。\n“大内存页”有助于 Linux 系统进行虚拟内存管理。顾名思义，除了标准的 4KB 大小的页面外，它们还能帮助管理内存中的巨大的页面。使用“大内存页”，你最大可以定义 1GB 的页面大小。\n在系统启动期间，你能用“大内存页”为应用程序预留一部分内存。这部分内存，即被“大内存页”占用的这些存储器永远不会被交换出内存。它会一直保留其中，除非你修改了配置。这会极大地提高像 Oracle 数据库这样的需要海量内存的应用程序的性能。\n在虚拟内存管理中，内核维护一个将虚拟内存地址映射到物理地址的表，对于每个页面操作，内核都需要加载相关的映射。如果你的内存页很小，那么你需要加载的页就会很多，导致内核会加载更多的映射表。而这会降低性能。\n使用“大内存页”，意味着所需要的页变少了。从而大大减少由内核加载的映射表的数量。这提高了内核级别的性能最终有利于应用程序的性能。\n简而言之，通过启用“大内存页”，系统具只需要处理较少的页面映射表，从而减少访问/维护它们的开销！\n运行下面命令来查看当前“大内存页”的详细内容。\n从上面输出可以看到，每个页的大小为 2MB（\n），并且系统中目前有 \n 个“大内存页”（\n）。这里“大内存页”的大小可以从 \n 增加到 \n。\n运行下面的脚本可以知道系统当前需要多少个巨大页。该脚本取之于 Oracle。\n将它以 \n 为名保存到 \n 中，然后运行之：\n你的输出类似如上结果，只是数字会有一些出入。\n这意味着，你系统需要 124 个每个 2MB 的“大内存页”！若你设置页面大小为 4MB，则结果就变成了 62。你明白了吧？\n本文最后一部分内容是配置上面提到的 \n ，然后重新加载。将下面内容添加到 \n 中，然后输入 \n 命令重新加载配置。\n注意我们这里多加了两个额外的页，因为我们希望在实际需要的页面数量之外多一些额外的空闲页。\n现在，内核已经配置好了，但是要让应用能够使用这些“大内存页”还需要提高内存的使用阀值。新的内存阀值应该为 126 个页 x 每个页 2 MB = 252 MB，也就是 258048 KB。\n你需要编辑 \n 中的如下配置：\n某些情况下，这些设置是在指定应用的文件中配置的，比如 Oracle DB 就是在 \n 中配置的。\n这就完成了！你可能还需要重启应用来让应用来使用这些新的巨大页。\n（LCTT 译注：此外原文有误，“透明大内存页”和“大内存页”不同，而且，在 Redhat 系统中，“大内存页” 不是默认启用的，而“透明大内存页”是启用的。因此这个段落删除了。）\n ", "tags": "IT技术,Linux", "front_image_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg"}
{"url_object_id": "23b91f36b0e3c52751b33dea744a641b", "title": "AI 从业者都会用到的 10 个深度学习方法", "create_date": "2018/03/12", "url": "http://blog.jobbole.com/113740/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2017/04/ff247977ac3e5237654ad324e8c880ed.jpg"], "praise_nums": 2, "fav_nums": 1, "comment_nums": "  评论", "content": "过去十年里，人们对机器学习的兴趣经历了爆炸式的整长。我们几乎每天都可以在计算机程序、行业会议和媒体上看到机器学习的身影。很多关于机器学习的讨论都混淆了“机器学习能做什么”和“人类希望机器学习能做什么”。从根本上讲，机器学习是运用算法从原始数据中提取信息，并用某种类型的模型进行表示，然后使用该模型对一些尚未用模型表示的其他数据来进行推断。\n神经网络就是机器学习各类模型中的其中一类，并且已经存在了至少50年。神经网络的基本单位是节点，它的想法大致来源于哺乳动物大脑中的生物神经元。生物大脑中的神经元节点之间的链接是随着时间推移不断演化的，而神经网络中的神经元节点链接也借鉴了这一点，会不断演化（通过“训练”的方式）。\n神经网络中很多重要框架的建立和改进都完成于二十世纪八十年代中期和九十年代初期。然而，要想获得较好结果需要大量的时间和数据，由于当时计算机的能力有限，神经网络的发展受到了一定的阻碍，人们的关注度也随之下降。二十一世纪初期，计算机的运算能力呈指数级增长，业界也见证了计算机技术发展的“寒武纪爆炸”——这在之前都是无法想象的。深度学习以一个竞争者的姿态出现，在计算能力爆炸式增长的十年里脱颖而出，并且赢得了许多重要的机器学习竞赛。其热度在2017年仍然不减。如今，在机器学习的出现的地方我们都能看到深度学习的身影。\n为了跟上时代的潮流，我参加了 Udacity 的“深度学习”课程。这是一个很好的入门课程，包括深度学习的动机和在 TensorFlow 中针对复杂的和/或大规模数据集进行学习的智能系统的设计。 对于课程作业，我使用和开发了用于图像识别的卷积神经网络，带有嵌入的自然语言处理以及运用递归神经网络/长期短期记忆的基于字符的文本生成程序。所有 Jupyter Notebook 的代码都在我的 \n。\n下图是课程作业的一个结果，词向量的 t-SNE 投影，通过相似性进行聚类。\n最近，我开始阅读关于深度学习的学术论文。根据我的个人研究，以下文章对这个领域的发展产生了巨大的影响：\n通过研究和学习，我学到了大量关于深度学习的相关知识。在这里，我想分享人工智能工程师 10 个用于解决机器学习问题的强大的深度学习方法。但是，我们首先需要定义什么是深度学习。\n如何定义深度学习是很多人面临的一个挑战，因为它的形式在过去的十年中已经慢慢地发生了改变。下图直观地展示了人工智能，机器学习和深度学习之间的关系。\n人工智能领域广泛，存在时间较长。深度学习是机器学习领域的一个子集，而机器学习是人工智能领域的一个子集。一般将深度学习网络与“典型”前馈多层网络从如下方面进行区分：\n上文提到的“更多的神经元”是指近年来神经元的数量不断增加，就可以用更复杂的模型来表示。层也从多层网络中每一层完全连接，发展到卷积神经网络中神经元片段的局部连接，以及与递归神经网络中的同一神经元的循环连接（与前一层的连接除外）。\n因此，深度学习可以被定义为以下四个基本网络框架中具有大量参数和层数的神经网络：\n在这篇文章中，我主要讨论三个框架：\n反向传播是一种计算函数偏导数（或梯度）的简单方法，它的形式是函数组合（如神经网络）。在使用基于梯度的方法求解最优化问题（梯度下降只是其中之一）时，需要在每次迭代中计算函数梯度。\n对于一个神经网络，其目标函数是组合形式。那么应该如何计算梯度呢？有2种常规方法：（i）\n。函数形式已知的情况下，只需要用链式法则（基础微积分）计算导数。（ii）\n。这种方法运算量很大，因为函数评估的数量级是 O(N)，其中 N 是参数的个数。与微分解析法相比，这种方法运算量更大，但是在调试时，通常会使用有限差分验证反向传播的效果。\n梯度下降的一个直观理解就是想象一条源自山顶的河流。这条河流会沿着山势的方向流向山麓的最低点，而这也正是梯度下降法的目标。\n我们所期望的最理想的情况就是河流在到达最终目的地（最低点）之前不会停下。在机器学习中，这等价于我们已经找到了从初始点（山顶）开始行走的全局最小值（或最优值）。然而，可能由于地形原因，河流的路径中会出现很多坑洼，而这会使得河流停滞不前。在机器学习术语中，这种坑洼称为局部最优解，而这不是我们想要的结果。有很多方法可以解决局部最优问题（这里不再讨论）。\n因此，由于地形（即函数性质）的限制，梯度下降算法很容易卡在局部最小值。但是，如果能够找到一个特殊的山地形状（比如碗状，术语称作凸函数），那么算法总是能够找到最优点。在进行最优化时，遇到这些特殊的地形（凸函数）自然是最好的。另外，山顶初始位置（即函数的初始值）不同，最终到达山底的路径也完全不同。同样，不同的流速（即梯度下降算法的学习速率或步长）也会导致到达目的地的方式有差异。是否会陷入或避开一个坑洼（局部最小值），都会受到这两个因素的影响。\n调整随机梯度下降优化算法的学习速率可以提升性能并减少训练时间。这被称作学习率退火或自适应学习率。训练中最简单也最常用的学习率自适应方法就是逐渐降低学习率。在训练初期使用较大的学习率，可以对学习率进行大幅调整；在训练后期，降低学习率，以一个较小的速率更新权重。这种方法在早期可以快速学习获得较好的权重，并在后期对权重进行微调。\n两个流行而简单的学习率衰减方法如下：\n拥有大量参数的深度神经网络是非常强大的机器学习系统。然而，在这样的网络中,过拟合是一个很严重的问题。而且大型网络的运行速度很慢，这就使得在测试阶段通过结合多个不同的大型神经网络的预测来解决过拟合问题是很困难的。Dropout 方法可以解决这个问题。\n其主要思想是，在训练过程中随机地从神经网络中删除单元（以及相应的连接），这样可以防止单元间的过度适应。训练过程中，在指数级不同“稀疏度”的网络中剔除样本。在测试阶段，很容易通过使用具有较小权重的单解开网络（single untwined network），将这些稀疏网络的预测结果求平均来进行近似。这能有效地避免过拟合，并且相对于其他正则化方法能得到更大的性能提升。Dropout 技术已经被证明在计算机视觉、语音识别、文本分类和计算生物学等领域的有监督学习任务中能提升神经网络的性能，并在多个基准数据集中达到最优秀的效果。\n最大池是一种基于样本的离散化方法。目标是对输入表征（图像、隐藏层输出矩阵等）进行下采样，降低维度并且允许对子区域中的特征进行假设。\n通过提供表征的抽象形式，这种方法可以在某种程度上解决过拟合问题。同样，它也通过减少学习参数的数目以及提供基本的内部表征转换不变性来减少计算量。最大池是通过将最大过滤器应用于通常不重叠的初始表征子区域来完成的。\n当然，包括深度网络在内的神经网络需要仔细调整权重初始值和学习参数。批量标准化能够使这个过程更加简单。\n在反向传播过程中，这些现象会导致梯度的偏移，这就意味着在学习权重以产生所需要的输出之前，梯度必须补偿异常值。而这将导致需要额外的时间才能收敛。\n批量标准化将这些梯度从异常值调整为正常值，并在小批量范围内（通过标准化）使其向共同的目标收敛。\n通常来说，学习率都比较小，这样只有一小部分的梯度用来校正权重，因为异常激活的梯度不应该影响已经学习好的权重。通过批量标准化，这些异常激活的可能性会被降低，就可以使用更大的学习率加速学习过程。\n长短期记忆网络（LSTM）和其他递归神经网络中的神经元有以下三个不同点：\nLSTM的强大之处在于它可以只基于当前的输入就决定上述所有。请看下方的图表：\n当前时间戳的输入信号 x(t) 决定了上述三点。输入门（input gate）决定了第一点，遗忘门（forget gate）决定了第二点，输出门（output gate）决定了第三点。只依赖输入就可以完成这三项决定。这是受到大脑工作机制的启发，大脑可以基于输入来处理突然的上下文语境切换。\n词嵌入模型的目的是针对每个词学习一个高维密集表征，其中嵌入向量之间的相似性显示了相应词语之间语义或句法的相似性。Skip-gram 是一种学习词嵌入算法的模型。\nskip-gram 模型（包括很多其它词嵌入模型）背后的主要思想是：\n换句话说，假设有一个句子，比如“cats are mammals”，如果用“dogs”替换“cats”，该句子仍然是有意义的。因此在这个例子中，“dogs”和“cats”有相似的上下文（即“are mammals”）。\n基于以上假设，我们可以考虑一个上下文窗口（包含 K 个连续项）。然后跳过其中一个词，试着学习一个可以得到除了跳过的这个词以外所有词项，并且可以预测跳过的词的神经网络。因此，如果两个词在一个大语料库中多次具有相似的上下文，那么这些词的嵌入向量将会是相似的。\n在自然语言处理中，我们希望将文档中的每一个单词表示为一个数值向量，使得出现在相似上下文中的单词具有相似或相近的向量表示。在连续词袋模型中，我们的目标是利用一个特定单词的上下文，预测该词。\n \n首先在一个大的语料库中抽取大量的句子，每看到一个单词，同时抽取它的上下文。然后我们将上下文单词输入到一个神经网络，并预测在这个上下文中心的单词。\n当我们有成千上万个这样的上下文词汇和中心词时，我们就得到了一个神经网络数据集的实例。然后训练这个神经网络，在经过编码的隐藏层的最终输出中，我们得到了特定单词的嵌入式表达。当我们对大量的句子进行训练时也能发现，类似上下文中的单词都可以得到相似的向量。\n我们来考虑一下卷积神经网络是如何处理图像的。假设有一张图像，对其应用卷积，并得到像素的组合作为输出。假设这些输出是边缘，再次应用卷积，那么现在的输出将是边缘或线的组合。然后再次应用卷积，此时的输出将是线的组合，以此类推。可以把它想象成是在每一层寻找一个特定的模式。神经网络的最后一层通常会变得非常特别。如果基于 ImageNet 进行训练，那么神经网络的最后一层或许就是在寻找儿童、狗或者飞机之类的完整图像。再往后倒退几层，可能会看到神经网络在寻找眼睛、耳朵、嘴巴或者轮子等组成部分。\n深度卷积神经网络中的每一层逐步建立起越来越高层次的特征表征，最后几层通常是专门针对输入数据。另一方面，前面的层则更为通用，主要用来在一大类图片中有找到许多简单的模式。\n迁移学习就是在一个数据集上训练卷积神经网络时，去掉最后一层，在不同的数据集上重新训练模型的最后一层。直观来讲，就是重新训练模型以识别不同的高级特征。因此，训练时间会减少很多，所以在没有足够的数据或者需要太多的资源时，迁移学习是一个很有用的工具。\n本文只是简单地对这些方法进行了概述，若想深入理解，建议继续阅读以下文章：\n深度学习是非常注重技术实践的。本文对每个新想法都没有太多具体的解释。大多数新想法的提出都会附带实验结果以证明它们的可行性。学习深度学习就像玩乐高，玩好乐高和掌握其他艺术一样具有挑战性，但是入门就相对容易很多的。", "tags": "IT技术,机器学习,深度学习", "front_image_path": "full/eadb28355fab57e9672e5c965147ef4caca04ac4.jpg"}
{"url_object_id": "9f16c4dc5a6cd2f4b07fef3690f49f8b", "title": "du 及 df 命令的使用（附带示例）", "create_date": "2018/03/23", "url": "http://blog.jobbole.com/113780/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2017/05/77d80105fd15f2465894827e23cc4842.jpeg"], "praise_nums": 1, "fav_nums": 2, "comment_nums": "  评论", "content": "在本文中，我将讨论 \n 和 \n 命令。\n 和 \n 命令都是 Linux 系统的重要工具，来显示 Linux 文件系统的磁盘使用情况。这里我们将通过一些例子来分享这两个命令的用法。\n（disk usage 的简称）是用于查找文件和目录的磁盘使用情况的命令。\n 命令在与各种选项一起使用时能以多种格式提供结果。\n下面是一些例子：\n该命令的输出将显示 \n 中的所有文件和目录以及显示块大小。\n它是 \n 目录的总大小\ndf（disk filesystem 的简称）用于显示 Linux 系统的磁盘利用率。（LCTT 译注：\n 可能应该是 disk free 的简称。）\n下面是一些例子。\n上面的命令以人类可读格式显示信息。\n 加上目标目录将以可读格式显示 \n 的信息。\n虽然 \n 和 \n 命令有更多选项，但是这些例子可以让你初步了解。如果在这里找不到你要找的东西，那么你可以参考有关命令的 man 页面。\n另外，\n阅读我的其他帖子，在那里我分享了一些其他重要和经常使用的 Linux 命令。\n如往常一样，欢迎你留下评论和疑问，因此在下面留下你的评论和疑问，我会回复你。", "tags": "IT技术,Linux", "front_image_path": "full/d1b17b98748a74826464a08e6d30a4ee1b15b171.jpg"}
{"url_object_id": "7a3fd4e360713292fb09393642fffc46", "title": "从业 24 年独立开发者：大多数同行都只看 5 年以内", "create_date": "2018/03/22", "url": "http://blog.jobbole.com/113778/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/03/db3f0f9a2c81173f5758eed4074b7543.jpg"], "praise_nums": 1, "fav_nums": 1, "comment_nums": "  评论", "content": "GameLook报道/有人说，游戏行业的竞争越来越激烈，游戏数量的增加使得曝光率问题日益严重，但在Jeff Vogel看来，真正热爱游戏研发的人，是不会抱怨这些问题的，因为大多数人做开发者都是从1-5年的时间看待自己的游戏研发职业生涯，而真正想要把游戏当作职业的人，往往是考虑40年或者更长的周期。\n在24年的独立游戏研发生涯中，Spiderweb Software创始人Jeff Vogel学到了很多东西。在3月20日举行的GDC独立游戏峰会上，他分享了一些自己的心得，有些观点让人十分意外。\nVogel强调，“游戏行业还是个朝阳产业，没有人无所不知，我们还有很多东西都需要弄明白，比如，如何设计这些游戏，如何创造、测试以及销售这些产品，如何为游戏做营销，如何给1亿美元预算的项目增加开箱子玩法而又不影响发布之后的口碑？”他提到自己的第一个游戏项目时候说，“这个项目并没有耗时太久，我当时有了一个想法，也就是小时候就喜欢的那些游戏，所以我要做的就是把小时候喜欢的游戏都回顾一遍，然后从每个游戏里汲取最好的创意。按照我的方法，我希望把它们变成让我觉得满意的游戏”。\nJeff Vogel的第一款游戏截图\n独立游戏非常适合做创新，但创新并不是唯一的出路。你必须知道，我们游戏行业的每个人都是站在巨人的肩膀上，所有的玩法都是在原有的玩法之上演变而来，我只了解自己喜欢的，然后复制这个想法，这就是我的创意过程，他鼓励其他开发者们用类似的方式，按照自己的个人需求去寻找创意，有人把游戏创意说的很玄，比如追求自己的灵感，这样的建议，但我的建议是千万不要这样做，这是一个非常现实的建议，我来说说原因。\n大多数人思考自己在游戏行业生涯的时候，往往是从1-5年的角度考虑问题，对于一些刚开始做游戏研发的人们来说，追寻自己的灵感似乎是非常合理的事情。但是，如果你把自己从事独立游戏研发行业的期限延长到40年或者更久的时间考虑，或许会有所帮助。\n这是一个特别长的时间，如果你在一个行业工作这么久，就会达到最高的工作效率，因为你需要维持生存，需要一个对应的生活方式，一个长久的想法，一个可持续的过程，保持自己不至于破产，因为，如果你因为一些想法而失去了立足之本，在接下来的40年里，它都会让你不断吃亏。\n当然，Vogel的创意也并不只是抄袭其他游戏的玩法，他对自己游戏的要求也是相对较高的，比如研发续作的时候，前作25%最差的部分需要被替换，提高整体游戏质量。他非常喜欢重复使用资源、代码和引擎，并认为所有人都不应该因此感到羞辱，比如有一个狼的icon，他在15款不同的游戏里使用过，“人们一直拿这个梗开我的玩笑，但我还是没有因此失业”。\n虽然Spiderweb的游戏有一定的用户群，而且口碑还不错，但这些游戏对于更大的用户群缺乏吸引力，有很大一部分原因是画质无法和3A游戏媲美，但Vogel说，“我非常反感所有人吐槽我的画面质量不够好，我也是投入了资金，专门招聘了美术师的，有些美术资源也是从比较大的渠道获得的，然而还是有人经常说，我的游戏画面很差，我以后再也不会浪费精力去专门提高美术质量了”。\n对于独立游戏开发者而言，这种批评的声音也是经常遇到的，人性有一部分是刻薄的，会对某些事物提出不合理的需求，而且在Steam这样的分销平台没有出现之前，Vogel做电话销售的时候就遇到过类似的问题。而到了互联网时代，这种问题就更加严重，“通常最愤怒的人不是完全匿名的，他们可能是五年前你的游戏最忠实的粉丝，然后你对游戏做出了改变，而且改掉的恰好是他们最喜欢的东西，他们就不再是你的粉丝，你要知道，有时候爱与恨之间的界限很小”。\n作为一个想要长期在游戏行业生存的开发者，Vogel表示，远离各种形式的骚扰是很重要的，作为一个成年人，虽然你很少会被人轻易激怒，但仍有很多事情会让你抓狂，所以Vogel基本上不会看自己的游戏在Steam平台的评论，也不访问论坛，如果被人喷，他还会暂时不登陆Twitter，等待事情平息了之后再登录，如果与一些玩家的关系闹僵，他会毫不犹豫的放弃这部分用户。Vogel说，“不要怕得罪用户，他们说客户总是对的，但实际上并非如此，用户一直是错的。但差别在于，你永远吵不赢他们。有时候你不得不对一部分玩家说，‘我的游戏不适合你，所以我不能增加你要的功能、不能做这样的资料片、不能满足你的要求’，对于你无法让他们满意的用户，退款是最好的方法”。\n《Geneforge 3》截图\n对于论坛管理，他说，“如果有人在论坛挑事，直接封掉就是了。但如果有人说，‘这些人又不会影响你的生意，不应该封他们’，那你可以连这些人一起封掉，这些消极的负面声音只会给你的社区带来不利影响，真正支持你的玩家会理解你的做法”。\n和所有的工作室一样，Spiderweb也经历了起伏，Vogel指出，2004年是最艰难的时候，那一年他的两款游戏，《Blades of Avernum》和《Geneforge 3》的销量都不佳。\n有人说，游戏开发者就像是艺术家，遭遇挫折在所难免，但Vogel认为，作为艺术家，你必须成长，“我们更像是玩具制造者，我们卖的是娱乐体验，我们的作品是用来给人们的大脑带来消遣的，我们卖的是惊喜，而自满、平淡无奇和重复会扼杀惊喜。如果你想做续作，很好，但你的续作最好是加入一些新东西，而且是越早越好，因为，如果玩家们开始发现你的需走只是重复，那么就会以拒绝购买的方式让你看到他们的答案”。\n最后，Vogel还提醒同行们不要过度消耗自己的健康，“不要因为熬夜工作而感到自豪，你需要睡眠才能活的长久，最好是挑一把好的椅子，因为有一天如果你的脊椎不行了，就会追悔莫及”。", "tags": "职场,游戏", "front_image_path": "full/e987a29d5f8519c5dcfb6963d8ba061ebf03b879.jpg"}
{"url_object_id": "c8f7206fc12fb03862d494d19208fd22", "title": "程序员如何规划职业路线？", "create_date": "2018/03/13", "url": "http://blog.jobbole.com/112048/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2017/03/4f255bd43f956c3db484a99d448b198e.jpg"], "praise_nums": 1, "fav_nums": 3, "comment_nums": 3, "content": "社区中并不缺少有关软件工程师职业发展的文章，甚至可以说是泛滥。很多人都能在这个话题上说两句，三五年工作经验的编程老鸟也好，架构师也好，技术 VP 也好，CTO 也好，都有各自的看法与实践经验。没有哪一套方法是适用于所有人的，这一套软件工程师职业发展纲要，也不过是在你踽踽前行的路上，迷茫时可用来参考借鉴。你的核心竞争力，永远是你的自身实力。切记！\n众所周知，软件工程师要做的工作就是写代码，准确地说，你的目标应该是写出满足业务需求并且无法找出 Bug 的代码，而不是写一大堆没用的文字。既然你的任务是写出高质量的代码，那么你首先应该训练的就是打字速度，你需要掌握键盘盲打技能，甚至还要爱上你的“编码神器”，并做到将此工具的用法烂熟于心，闭上眼睛都能正确敲中你想要的快捷键。\n当你完全驾驭了计算机的输入设备以后，你需要进一步了解计算机的内部工作原理，不是让你把机器大卸八块，而是你需要全面了解计算机的组成结构与工作原理。如果你不是计算机科班出生也没关系，在网上买一本关于计算机组成原理的书自学即可。你无需做到精通，能全面了解即可，因为接下来你需要在编程的世界中，慢慢去体会计算机的工作感受，你就是计算机的管理者。\n好了，现在是时候学习一门编程语言了，最好的选择是 Java，为什么呢？原因很简单，因为市场需求量最大，我敢保证，你学 Java 肯定比学 PHP 更容易找到工作（希望 PHP 程序员们淡定一些，其实我始终认为 PHP 是世界上最好的编程语言）。当你在学习 Java 时，首先需要掌握它啰里吧嗦的编程语法，此时没有什么比写一个“Hello World”来得更爽快一些。随后你需要深刻理解的是 Java 的面向对象概念（每次我说到面向对象，总会被一些单身汉吐槽，其实我想说，对象是可以 new 出来的），这些概念看上去比较虚，但是它们却能撑起一个强大的软件架构。所以，在面向对象技术上面花再多功夫都不为过，因为它能训练我们对业务的抽象能力，就像当初我们学习数学一样，它能训练我们的逻辑思维能力。\n看书、看视频、看源码、看技术文档，其实这些都是较为低效的学习方法，掌握编程技能的捷径就是拜一位资深的程序员为师，你可以尊称他为“码神”，记得一定要把他伺候好，让他愿意传授一些编程技能给你，其实也就是一个微笑外加一顿小龙虾的事情，他就能被你征服。一定要看他写的代码，思考为什么他会这样写，一定要将你不理解的地方记录下来，并且在下班之前紧紧地抓住他，让他一次给你讲个够，此时你一定会有一种打通任督二脉的畅快之感。所谓“师傅领进门，修行在个人”，你需要比你师傅更加努力，甚至十倍于他人的付出，才能在编程之路上尝到甜头。此时你需要学习更加高深的武功，研究更加优秀的源码，实践更有挑战的项目，还需要花整块时间，系统地看技术文档以及技术参考书。假如你想成为架构师，不妨看看我所著的《架构探险》这本书，也许它会对你的专业技能有所帮助。\n你最好要让自己变成一位豁达开朗之人，千万不要吝啬，一定要懂得分享你所学的专业技能。可以尝试做点自己的开源项目，并让这个开源项目变得更加开放，不妨结合开源，写点技术博客，并厚着脸皮给你身边的朋友阅读。这件事情一定要持之以恒，不要担心有人吐槽你，你肯定会被吐槽，那是因为大家在关注你，此时你需要更加努力，让自己变得足够专业。当你成为真正的“大神”时，就不会有人再吐槽你了，他们只会吐槽自己的技术不如你，此时你将得到的是无限的膜拜和称赞。相信我，这绝不是奇迹。在学习专业技能之路上，多一点自信，多一点勤奋，多一点思考，再争取一点机会，你就会成功。\n如果将专业技能比喻为“硬技能”，那么在我们的职场中，与专业性无关的技能就可以归纳为“软技能”了。但每当我提到软技能时，难免会让人误解为这是“务虚”的一种功夫，我们虽然是“吃软饭的”（做软件开发的），但我们却十分讨厌虚伪。没错！我也很厌恶虚伪之人，尤其是在职场中遇到这样的人物，我从心底鄙视他们，但我从来不会和他们发生任何冲突，反而还能和他们愉快地共事，这种本领靠的就是软技能。\n软件工程师每天都在和机器打交道，机器是没有感情的，你告诉它是0，它一定不会认为是1。但我们与人打交道却不一样，你告诉他是真，他却可能认为是假。与人打交道，正是软件工程师们最为欠缺的方面，有些软件工程师甚至害怕与人交流，害怕在公开场合讲话，害怕抛头露面，害怕做一些组织性的工作。如果你也有以上这些心里负担，那么恭喜你！因为你即将从本文中找到克服这些困难的灵丹妙药，至少我希望是这样。\n需要强调的是，软技能是一种职场必备的核心技能，我敢直言，如果缺乏这方面的技能，你的职业生涯将会变得非常糟糕。软技能包括的方面非常广泛，沟通、协调、组织、气场这些都是最基本的软技能，甚至情商也是一种软技能，会不会讲话，听不听得明白，这些都是软技能。那么我们不妨先从沟通这项软技能开始吧，因为我认为他是软件工程师最重要的软技能之一。\n很多人都容易将沟通理解为讲话，说一个人语言很流利，很会讲话，口若悬河，夸夸其谈，其实并非他的沟通能力很强。我认为，沟通可以理解为两方面，即“沟”和“通”。“沟”指的是你将心中所想很清晰地表达出来给对方听，考验的是你的表达能力；“通”指的是让你确信对方是否真明白你所表达的意思，考验的是你的倾听能力。所以，我们很多时候都是在“沟”，往往忽略了“通”，从而形成了“沟而不通”的情况，因此，现在全世界人民都在提倡如何“有效沟通”。还是用一个示例来说话吧。\n当领导交给你一项棘手的工作，但你不知道如何开始进行这项工作，此时你应该如何应对当前的挑战呢？绝大多数人会硬着头皮去做，他们希望通过自己的努力，可以顺利完成任务，但结果往往却无法让领导满意。少数人会主动向领导咨询，以寻求领导对自己的帮助。此时应该如何与领导对话呢？似乎并非很多人都清楚。下面这段话是我的套路，仅供参考。\n沟通是不是很有趣？其实沟通是一门学问，我们花一辈子时间都在学习，都在改进自己的沟通方式，目的仅为愉快地和身边的人一起“玩耍”，让此生感到愉悦。\n当你已经掌握了必备的专业技能，也具备了让你脱颖而出的软技能，那么接下来你将思考的是自己该走那条路了，继续做软件工程师，还是做软件工程师的 leader？下面这段话将告诉你答案。\n首先要澄清的是：我并非职业导师，更不是人生教父，所有的路都由你自己选择，我的责任是告诉你，我认为行之有效的方法。\n当你正走在职场的十字路口徘徊，思考走技术，还是走管理？我的答案只有一个：根据你自己的优势来决定。合理利用好自己的优势，会让自己走的更加顺畅，让自己无怨无悔。还是举一个例子来说明吧。\n前段时间有位朋友在微信上私聊我，他也遇到了这个问题，继续做技术，还是转管理？我当时是这样问他的，但我希望你可以用这样的方式来问自己。\n当我们在纠结是否应该转管理时，不妨首先理解一下什么是管理？以及什么是管理者？只有当我们正确理解了这些概念以后，再来思考自己是否具备这样的特征，才能顺利帮助自己转型。\n管理（management）是协调和监督他人的工作，从而使他人的工作可以有效率且有成效地完成。效率（efficiency）指的是以尽可能少的投入，以获得尽可能多的产出，效率常常被说成“正确地做事”，即不浪费资源。成效（effectiveness）常常被称为“做正确的事”，即做那些可以实现目标的工作活动。管理者（manager）就是完成所有管理工作，并使组织目标能够实现的人。管理者的工作包括计划（planning）、组织（organizing）、领导（leading）和控制（controlling）四种职能。\n以上都是管理学告诉我们的知识，如果你想成为一名管理者，那么你必须首先正确理解这些概念的真实含义，才能完全驾驭管理者的岗位，否则你会从管理岗位上摔下来，自己一定伤得不轻。\n如果你想成为一名优秀的管理者，那么你需要做些什么呢？\n如果团队和你共事过，那么团队应该觉得他们是幸运的，因为你能够让他们更加愉快和高效地工作。\n不论选择技术还是管理，在任何时候都不要放弃你的硬技能，因为它是你的“生存之本”，同时你也需要具备强大的软技能，因为它是你的“发展之源”。\n学习硬技能其实是有捷径的，你无需一味地学习这些知识点，更多的其实是与人交流以及加以应用。软技能其实是可以训练的，你只需抓住一切可以抓住的机会，有意识地加以训练和反思，你就能悟出很多宝贵的经验。软件开发是一门艺术，你需要能够静得下心，不断地优化和雕琢你的作品，因此你需要具备工匠精神。如果你想成为一名工匠领袖，那么你就应该比他人思考得更多、更高、更深、更全面，你需要更多的软技能。你只有认识到自己的优势，才能正确地选择自己的职业路线。\n祝你成功！", "tags": "职场,程序员,职场", "front_image_path": "full/d102994dcc342e0686843d89a7518432502d5ff3.jpg"}
{"url_object_id": "d7679705b6786b2bb8061b616470a651", "title": "深入学习 Redis（1）：Redis 内存模型", "create_date": "2018/03/27", "url": "http://blog.jobbole.com/113789/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2016/04/49961db8952e63d98b519b76a2daa5e2.png"], "praise_nums": 2, "fav_nums": 1, "comment_nums": "  评论", "content": "Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。\n我们使用Redis时，会接触Redis的5种对象类型（字符串、哈希、列表、集合、有序集合），丰富的类型是Redis相对于Memcached等的一大优势。在了解Redis的5种对象类型的用法和特点的基础上，进一步了解Redis的内存模型，对Redis的使用有很大帮助，例如：\n1、估算Redis内存使用量。目前为止，内存的使用成本仍然相对较高，使用内存不能无所顾忌；根据需求合理的评估Redis的内存使用量，选择合适的机器配置，可以在满足需求的情况下节约成本。\n2、优化内存占用。了解Redis内存模型可以选择更合适的数据类型和编码，更好的利用Redis内存。\n3、分析解决问题。当Redis出现阻塞、内存占用等问题时，尽快发现导致问题的原因，便于分析解决问题。\n这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内存模型的应用。\n在后面的文章中，会陆续介绍关于Redis高可用的内容，包括主从复制、哨兵、集群等等，欢迎关注。\n \n工欲善其事必先利其器，在说明Redis内存之前首先说明如何统计Redis使用内存的情况。\n在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：\n其中，info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；memory是参数，表示只显示内存相关的信息。\n返回结果中比较重要的几个说明如下：\n（1）\nRedis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。\n（2）\nRedis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。\n因此，used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。\n由于在实际应用中，Redis的数据量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片相比，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。\n（3）\n内存碎片比率，该值是used_memory_rss / used_memory的比值。\nmem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio<1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。\n一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；上面截图中的mem_fragmentation_ratio值很大，是因为还没有向Redis中存入数据，Redis进程本身运行的内存使得used_memory_rss 比used_memory大得多。\n（4）\nRedis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。\nRedis作为内存数据库，在内存中存储的内容主要是数据（键值对）；通过前面的叙述可以知道，除了数据以外，Redis的其他部分也会占用内存。\nRedis的内存占用主要可以划分为以下几个部分：\n作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。\nRedis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。\nRedis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。\n补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。\n缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。\n内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。\n内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。\n如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。\n关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。\n下图是执行set hello world时，所涉及到的数据模型。\n图片来源：https://searchdatabase.techtarget.com.cn/7-20218/\n（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。\n（2）Key：图中右上角可见，Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。\n（3）redisObject：Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。\n实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。\n（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。\n下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。\nRedis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。\njemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。\njemalloc划分的内存单元如下图所示：\n图片来源：http://blog.csdn.net/zhengpeitao/article/details/76573053\n例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。\n前面说到，Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。\nredisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。\nredisObject的定义如下（不同版本的Redis可能稍稍有所不同）：\nredisObject的每个字段的含义和作用如下：\ntype字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。\n当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下图所示：\nencoding表示对象的内部编码，占4个比特。\n对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。\n通过object encoding命令，可以查看对象采用的编码方式，如下图所示：\n5种对象类型对应的编码方式以及使用条件，将在后面介绍。\nlru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。\n通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。\nlru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。\nrefcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。\nRedis中被多次使用的对象(refcount>1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。\nRedis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。\n虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。\n就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0~9999的整数值；当Redis需要使用值为0~9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。\n共享对象的引用次数可以通过object refcount命令查看，如下图所示。命令执行的结果页佐证了只有0~9999之间的整数会作为共享对象。\nptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。\n综上所述，redisObject的结构与对象类型、编码、内存回收、共享对象都有关系；一个redisObject对象的大小为16字节：\n4bit+4bit+24bit+4Byte+8Byte=16Byte。\nRedis没有直接使用C字符串(即以空字符’\\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。\nsds的结构如下：\n其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。下面是两个例子。\n图片来源：《Redis设计与实现》\n通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。\nSDS在C字符串的基础上加入了free和len字段，带来了很多好处：\n此外，由于SDS中的buf仍然使用了C字符串（即以’\\0’结尾），因此SDS可以使用C字符串库中的部分函数；但是需要注意的是，只有当SDS用来存储文本数据时才可以这样使用，在存储二进制数据时则不行（’\\0’不一定是结尾）。\nRedis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。\n只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。\n前面已经说过，Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。\nRedis各种对象类型支持的内部编码如下图所示(图中版本是Redis3.0，Redis后面版本中又增加了内部编码，略过不提；本章所介绍的内部编码都是基于3.0的)：\n图片来源：《Redis设计与实现》\n关于Redis内部编码的转换，都符合以下规律：\n字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。\n字符串长度不能超过512MB。\n字符串类型的内部编码有3种，它们的应用场景如下：\n示例如下图所示：\nembstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。\n当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。\n而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。示例如下图所示：\n列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。\n列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。\n双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：\n图片来源：《Redis设计与实现》\n通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。\n压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的\n(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。\n压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。\n只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。\n下图展示了列表编码转换的特点：\n其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。\n哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用“内层的哈希”时，代表的是redis对外提供的5种对象类型的一种；使用“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。\n内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。\n压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。\nhashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。\n正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：\n图片改编自：《Redis设计与实现》\n下面从底层向上依次介绍各个部分：\ndictEntry结构用于保存键值对，结构定义如下：\n其中，各个属性的功能如下：\n在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。\nbucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。\ndictht结构如下：\n其中，各个属性的功能说明如下：\n一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。\ndict结构如下：\n其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。\nht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。\n因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。\n如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。\n只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。\n下图展示了Redis内层的哈希编码转换的特点：\n集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。\n一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。\n集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。\n哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。\n整数集合的结构定义如下：\n其中，encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的；length表示元素个数。\n整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于集合数量较少，因此操作的时间并没有明显劣势。\n只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。\n下图展示了集合编码转换的特点：\n有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。\n有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。\n跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。\n只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。\n下图展示了有序集合编码转换的特点：\n了解Redis的内存模型之后，下面通过几个例子说明其应用。\n要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括前面介绍的hashtable、sds、redisobject、各种对象类型的编码方式等。\n下面以最简单的字符串类型来进行说明。\n假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。在估算占据空间之前，首先可以判定字符串类型使用的编码方式：embstr。\n90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。\n每个dictEntry占据的空间包括：\n1)       一个dictEntry，24字节，jemalloc会分配32字节的内存块\n2)       一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块\n3)       一个redisObject，16字节，jemalloc会分配16字节的内存块\n4)       一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块\n5)       综上，一个dictEntry需要32+16+16+16=80个字节。\nbucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。\n因此，可以估算出这90000个键值对占据的内存大小为：90000*80 + 131072*8 = 8248576。\n下面写个程序在redis中验证一下：\n运行结果：8247552\n理论值与结果值误差在万分之1.2，对于计算需要多少内存来说，这个精度已经足够了。之所以会存在误差，是因为在我们插入90000条数据之前redis已分配了一定的bucket空间，而这些bucket空间尚未使用。\n作为对比将key和value的长度由7字节增加到8字节，则对应的SDS变为17个字节，jemalloc会分配32个字节，因此每个dictEntry占用的字节数也由80字节变为112字节。此时估算这90000个键值对占据内存大小为：90000*112 + 131072*8 = 11128576。\n在redis中验证代码如下（只修改插入数据的代码）：\n运行结果：11128576；估算准确。\n对于字符串类型之外的其他类型，对内存占用的估算方法是类似的，需要结合具体类型的编码方式来确定。\n了解redis的内存模型，对优化redis内存占用有很大帮助。下面介绍几种优化场景。\n（1）利用jemalloc特性进行优化\n上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。\n例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。\n（2）使用整型/长整型\n如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。\n（3）共享对象\n利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。\n考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。\n（4）避免过度设计\n然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。\n如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。\n内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。\n如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。\n如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。\n要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。\n《Redis开发与运维》\n《Redis设计与实现》\nhttps://redis.io/documentation\nhttp://redisdoc.com/server/info.html\nhttps://www.cnblogs.com/lhcpig/p/4769397.html\nhttps://searchdatabase.techtarget.com.cn/7-20218/\nhttp://www.cnblogs.com/mushroom/p/4738170.html\nhttp://www.imooc.com/article/3645\nhttp://blog.csdn.net/zhengpeitao/article/details/76573053\n ", "tags": "IT技术,Redis,数据库", "front_image_path": "full/c766feed221138f7946130756cddfc7e86e388b4.jpg"}
{"url_object_id": "8dc9c672255230d0cfa267884f1e9bb5", "title": "利用 DB 实现分布式锁的思路", "create_date": "2018/03/09", "url": "http://blog.jobbole.com/113707/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2015/07/8266f93c2d45d97e0d52e71428ca372e.png"], "praise_nums": 1, "fav_nums": 3, "comment_nums": 4, "content": "", "tags": "IT技术,分布式", "front_image_path": "full/cd53a2302bc0852583e1e611cf280b011948f392.jpg"}
{"url_object_id": "a47361c034c83e65bad8c6c27ce61a3b", "title": "Redis 集群部署及踩过的坑", "create_date": "2018/03/13", "url": "http://blog.jobbole.com/113760/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2016/04/49961db8952e63d98b519b76a2daa5e2.png"], "praise_nums": 1, "fav_nums": 3, "comment_nums": "  评论", "content": "此处默认已安装好单台redis，如果不会可以参照《\n》\n \n我们在Redis安装目录下创建目录cluster，并编写7000.conf~7005.conf 6个配置文件，这6个配置文件用来启动6个实例，后面将使用这6个实例组成集群。\n以7000.conf为例，配置文件需要填写如下几项：\n分别启动6个实例\n启动成功后，看一下进程\n至此，ip=192.168.186.91机器上创建了6个实例，端口号为port=7000~7005。\n \n这一步骤中出现了bug,度娘告诉我是Ruby版本太低，需要升级版本。\n安装rvm，我不知道这是个什么东西，但是感觉像是Ruby的一个包管理器。\n这一操作得到了：\ngpg2 –recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\n然后利用该密钥下载Ruby并升级。\n接着，source环境，让rvm可用。\n查看Ruby可用版本\n可以看到最新的版本是2.4.1，本文安装2.3.0\n至此，我们升级了Ruby的版本。\n到目前为止，我们的Ruby和运行redis-trib.rb需要的环境安装完成了。\n \n有了Ruby执行环境，可以开始将之前的6个实例组建成集群了。\n有三个master，有三个是slave。 后面跟上6个实例就好了，形式就是ip:port\n【此处有坑】\n第一坑\n需要将redis-trib.rb复制到/usr/local/bin目录下。\n第二坑\n踩完第一坑后，继续执行，发现了第二坑，还好有度娘，但是网上各种说法都有（主要参照了《\n》的博客），发现错误的原因是redis数据库没有清除。\n第三坑\n还是度娘靠谱，在《\n》博客中找到了答案。\n这是由于之间创建集群没有成功,需要将nodes.conf和dir里面的文件全部删除。\n然后重启redis服务。\n \n登录集群客户端，-c标识以集群方式登录\n查看集群状态", "tags": "IT技术,Redis,数据库", "front_image_path": "full/c766feed221138f7946130756cddfc7e86e388b4.jpg"}
{"url_object_id": "346c3258b4b9bfbca9483337a14be393", "title": "我从 1000 份代码审查中学到了什么", "create_date": "2018/03/12", "url": "http://blog.jobbole.com/113741/", "front_image_url": ["http://wx3.sinaimg.cn/mw690/63918611gy1fpaca90vycj218g0tmtek.jpg"], "praise_nums": 1, "fav_nums": 0, "comment_nums": "  评论", "content": "我看到有些建议不断重复出现，所以我决定整理一个清单，与诸位分享。\n这是我的 3（额外 +1）个最常见的代码审查建议。\n我见过的一个常见模式是：\n这种模式实际上导致了我做的移动应用程序崩溃，我们当时使用的搜索后端开始抛出异常。而应用程序的 API 服务器中也有一些类似的代码。从应用程序的角度来看，它成功获取了 200 个响应，只是每个搜索请求返回的是空列表。\n如果当时 API 直接抛出异常，那么我们的监控系统就会立即检测到并修复它。\n很多时候，当你捕获一个异常时，你会希望它返回一个空对象。Java 中的空对象包括 Optional.empty()、null 和空列表，而它们在 URL 解析中经常出现。如果 URL 不能从一个字符串中正确解析时，先不要返回 null，而是停下来问问自己：“为什么 URL 格式不正确？这不是我们应该在上游解决的数据问题吗？”\n空对象不是解决此类问题的合适工具。\n这个建议基本上与\n相反。\n我经常看到类似这样的代码：\n尽可能具体的类型可以让你避免整个类的错误，这基本上是大家选择强类型语言（如 Java）的原因。\n所以现在的问题是：那些想要写强类型语言的程序员，最终是怎么写出糟糕的字符串类型的代码哪？答案是：因为外部世界不是强类型的。字符串通常来自许多不同的地方，比如：\n这些情况下，你应该使用以下策略来避免这个问题：\n。这是一个例子：\n它带给我们许多好处：1、能够立刻发现格式不正确的数据；如果有任何问题，应用程序会提前显示并终止。2、一旦数据通过验证，你不必在整个应用程序中捕获解析异常。3、强类型使得签名具有更多信息，这样你就无需在每个方法上写 javadoc。\n（可选）类是 Java 8 中最好的特性之一，它表示一个可以合理存在或不存在的实体。\n问题时间：唯一用缩写来指代的异常是什么？答：NPE （Null Pointer Exception，空指针异常）。这是迄今为止 Java 中最常见的异常，被称为\n。\n 允许你从程序中完全删除 NPE。但是，你必须正确地使用它。这里有一些关于如何使用 \n 的建议：\n你应该尽量避免类似的方法：\n所有要避免的方法有什么共同点？他们都使用容器对象，比如 Optional，List 或 Task 作为方法的参数。当返回类型是同一类型的容器（即，一个参数的方法采用 Optional 并返回一个 Optional），情况会变得更糟糕。\n为什么？\n相比 ① \n，② \n更具有灵活性。\n如果你有 \n，那么你可以使用 ①，也可以通过  \n 函数“提升（lifting）” （比如 \n）来使用 ②.\n但是，如果你只有 B，那么你可以很容易地使用 ②，却不能使用 ①，很明显，② 是一个更灵活的选择。\n我喜欢称之为“Unlift”，因为它与普通函数的实用方法“Lift”恰好相反。应用这些重写能使方法更灵活，调用更轻松。", "tags": "IT技术,Code Review,代码审查", "front_image_path": "full/72fd692cdd9ccd44d3da74f6eda1119635b48c27.jpg"}
{"url_object_id": "20d0b326ed26dff7f3c5708bdf46c1a5", "title": "Linux 启动过程分析", "create_date": "2018/03/13", "url": "http://blog.jobbole.com/113768/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "praise_nums": 1, "fav_nums": 4, "comment_nums": "  评论", "content": "关于开源软件最古老的笑话是：“代码是自具文档化的self-documenting”。经验表明，阅读源代码就像听天气预报一样：明智的人依然出门会看看室外的天气。本文讲述了如何运用调试工具来观察和分析 Linux 系统的启动。分析一个功能正常的系统启动过程，有助于用户和开发人员应对不可避免的故障。\n从某些方面看，启动过程非常简单。内核在单核上以单线程和同步状态启动，似乎可以理解。但内核本身是如何启动的呢？\n 和引导程序bootloader具有哪些功能？还有，为什么以太网端口上的 LED 灯是常亮的呢？\n请继续阅读寻找答案。在 GitHub 上也提供了 \n。\nOFF 状态表示系统没有上电，没错吧？表面简单，其实不然。例如，如果系统启用了局域网唤醒机制（WOL），以太网指示灯将亮起。通过以下命令来检查是否是这种情况：\n其中 <interface name>\n 是网络接口的名字，比如 \n。（\n 可以在同名的 Linux 软件包中找到。）如果输出中的 \n 显示 \n，则远程主机可以通过发送 \n 来启动系统。如果您无意远程唤醒系统，也不希望其他人这样做，请在系统 BIOS 菜单中将 WOL 关闭，或者用以下方式：\n响应魔法数据包的处理器可能是网络接口的一部分，也可能是 \n（BMC）。\nBMC 不是唯一的在系统关闭时仍在监听的微控制器（MCU）。x86_64 系统还包含了用于远程管理系统的英特尔管理引擎（IME）软件套件。从服务器到笔记本电脑，各种各样的设备都包含了这项技术，它开启了如 KVM 远程控制和英特尔功能许可服务等 \n。根据 \n，\n。坏消息是，要禁用 IME 很难。Trammell Hudson 发起了一个 \n，它可以清除一些相对恶劣的 IME 组件，比如嵌入式 Web 服务器，但也可能会影响运行它的系统。\nIME 固件和系统管理模式System Management Mode（SMM）软件是 \n 的，并运行在单独的平台控制器单元Platform Controller Hub上（LCTT 译注：即南桥芯片），而不是主 CPU 上。然后，SMM 启动位于主处理器上的通用可扩展固件接口Universal Extensible Firmware Interface（UEFI）软件，相关内容 \n。Google 的 Coreboot 小组已经启动了一个雄心勃勃的 \n（NERF）项目，其目的不仅是要取代 UEFI，还要取代早期的 Linux 用户空间组件，如 systemd。在我们等待这些新成果的同时，Linux 用户现在就可以从 Purism、System76 或 Dell 等处购买 \n 的笔记本电脑，另外 \n 还是值得期待的。\n除了启动那些问题不断的间谍软件外，早期引导固件还有什么功能呢？引导程序的作用是为新上电的处理器提供通用操作系统（如 Linux）所需的资源。在开机时，不但没有虚拟内存，在控制器启动之前连 DRAM 也没有。然后，引导程序打开电源，并扫描总线和接口，以定位内核镜像和根文件系统的位置。U-Boot 和 GRUB 等常见的引导程序支持 USB、PCI 和 NFS 等接口，以及更多的嵌入式专用设备，如 NOR 闪存和 NAND 闪存。引导程序还与 \n（TPM）等硬件安全设备进行交互，在启动最开始建立信任链。\n包括树莓派、任天堂设备、汽车主板和 Chromebook 在内的系统都支持广泛使用的开源引导程序 \n。它没有系统日志，当发生问题时，甚至没有任何控制台输出。为了便于调试，U-Boot 团队提供了一个沙盒，可以在构建主机甚至是夜间的持续集成（CI）系统上测试补丁程序。如果系统上安装了 Git 和 GNU Compiler Collection（GCC）等通用的开发工具，使用 U-Boot 沙盒会相对简单：\n在 x86_64 上运行 U-Boot，可以测试一些棘手的功能，如 \n 的重新分区、基于 TPM 的密钥操作以及 USB 设备热插拔等。U-Boot 沙盒甚至可以在 GDB 调试器下单步执行。使用沙盒进行开发的速度比将引导程序刷新到电路板上的测试快 10 倍，并且可以使用 \n 恢复一个“变砖”的沙盒。\n引导程序完成任务后将跳转到已加载到主内存中的内核代码，并开始执行，传递用户指定的任何命令行选项。内核是什么样的程序呢？用命令 \n 可以看到它是一个 “bzImage”，意思是一个大的压缩的镜像。Linux 源代码树包含了一个可以解压缩这个文件的工具—— \n：\n内核是一个 \n（ELF）的二进制文件，就像 Linux 的用户空间程序一样。这意味着我们可以使用 \n 包中的命令，如 \n 来检查它。比较一下输出，例如：\n这两个二进制文件中的段内容大致相同。\n所以内核必须像其他的 Linux ELF 文件一样启动，但用户空间程序是如何启动的呢？在 \n 函数中？并不确切。\n在 \n 函数运行之前，程序需要一个执行上下文，包括堆栈内存以及 \n、\n 和 \n 的文件描述符。用户空间程序从标准库（多数 Linux 系统在用 “glibc”）中获取这些资源。参照以下输出：\nELF 二进制文件有一个解释器，就像 Bash 和 Python 脚本一样，但是解释器不需要像脚本那样用 \n 指定，因为 ELF 是 Linux 的原生格式。ELF 解释器通过调用 \n 函数来用所需资源 \n，这个函数可以从 glibc 源代码包中找到，可以 \n。内核显然没有解释器，必须自我配置，这是怎么做到的呢？\n用 GDB 检查内核的启动给出了答案。首先安装内核的调试软件包，内核中包含一个未剥离的unstripped vmlinux，例如 \n，或者从源代码编译和安装你自己的内核，可以参照 \n 中的指令。\n 后加 \n 可显示 ELF 段 \n。在 \n 中用 \n 列出程序执行的开头，其中 \n 是 \n 的十六进制开头。用 GDB 可以看到 x86_64 内核从内核文件 \n 开始启动，在这个文件中我们找到了汇编函数 \n，以及一段明确的代码显示在调用 \n 函数之前创建了堆栈并解压了 zImage。ARM 32 位内核也有类似的文件 \n。\n 不针对特定的体系结构，所以这个函数驻留在内核的 \n 中。\n 可以说是 Linux 真正的 \n 函数。\n在引导时，内核需要硬件信息，不仅仅是已编译过的处理器类型。代码中的指令通过单独存储的配置数据进行扩充。有两种主要的数据存储方法：\n 和 \n。内核通过读取这些文件了解每次启动时需要运行的硬件。\n对于嵌入式设备，设备树是已安装硬件的清单。设备树只是一个与内核源代码同时编译的文件，通常与 \n 一样位于 \n 目录中。要查看 ARM 设备上的设备树的内容，只需对名称与 \n 匹配的文件执行 \n 包中的 \n 命令即可，这里 \n 是指设备树二进制文件device-tree binary。显然，只需编辑构成它的类 JSON 的文件并重新运行随内核源代码提供的特殊 \n 编译器即可修改设备树。虽然设备树是一个静态文件，其文件路径通常由命令行引导程序传递给内核，但近年来增加了一个 \n 的功能，内核在启动后可以动态加载热插拔的附加设备。\nx86 系列和许多企业级的 ARM64 设备使用 \n 机制。与设备树不同的是，ACPI 信息存储在内核在启动时通过访问板载 ROM 而创建的 \n 虚拟文件系统中。读取 ACPI 表的简单方法是使用 \n 包中的 \n 命令。例如：\n是的，你的 Linux 系统已经准备好用于 Windows 2001 了，你要考虑安装吗？与设备树不同，ACPI 具有方法和数据，而设备树更多地是一种硬件描述语言。ACPI 方法在启动后仍处于活动状态。例如，运行 \n 命令（在 \n 包中），然后打开和关闭笔记本机盖会发现 ACPI 功能一直在运行。暂时地和动态地 \n 是可能的，而永久地改变它需要在引导时与 BIOS 菜单交互或刷新 ROM。如果你遇到那么多麻烦，也许你应该 \n，这是开源固件的替代品。\n 中的代码竟然是可读的，而且有趣的是，它仍然在使用 1991 – 1992 年的 Linus Torvalds 的原始版权。在一个刚启动的系统上运行 \n，其输出主要来源于此文件。第一个 CPU 注册到系统中，全局数据结构被初始化，并且调度程序、中断处理程序（IRQ）、定时器和控制台按照严格的顺序逐一启动。在 \n 函数运行之前，所有的时间戳都是零。内核初始化的这部分是同步的，也就是说执行只发生在一个线程中，在最后一个完成并返回之前，没有任何函数会被执行。因此，即使在两个系统之间，\n 的输出也是完全可重复的，只要它们具有相同的设备树或 ACPI 表。Linux 的行为就像在 MCU 上运行的 RTOS（实时操作系统）一样，如 QNX 或 VxWorks。这种情况持续存在于函数 \n 中，该函数在终止时由 \n 调用。\n函数 \n 产生了一个新进程以运行 \n，并调用了 \n。用户可以通过将 \n 附加到内核命令行来监控 \n，这样每运行一次 \n 函数就会产生 一个 \n 条目。\n 会历经七个连续的级别：early、core、postcore、arch、subsys、fs、device 和 late。\n 最为用户可见的部分是所有处理器外围设备的探测和设置：总线、网络、存储和显示器等等，同时加载其内核模块。\n 也会在引导处理器上产生第二个线程，它首先运行 \n，然后等待调度器分配工作。\n 也可以 \n。在较新的内核中，如果 \n 的输出中出现 “Bringing up secondary CPUs…” 等字样，系统便使用了 SMP。SMP 通过“热插拔” CPU 来进行，这意味着它用状态机来管理其生命周期，这种状态机在概念上类似于热插拔的 U 盘一样。内核的电源管理系统经常会使某个核core离线，然后根据需要将其唤醒，以便在不忙的机器上反复调用同一段的 CPU 热插拔代码。观察电源管理系统调用 CPU 热插拔代码的 \n 称为 \n。\n请注意，\n 中的代码在 \n 运行时几乎已执行完毕：引导处理器已经完成了大部分一次性初始化操作，其它核无需重复。尽管如此，跨 CPU 的线程仍然要在每个核上生成，以管理每个核的中断（IRQ）、工作队列、定时器和电源事件。例如，通过 \n 命令可以查看服务每个 CPU 上的线程的 softirqs 和 workqueues。\n其中，PSR 字段代表“处理器processor”。每个核还必须拥有自己的定时器和 \n 热插拔处理程序。\n那么用户空间是如何启动的呢？在最后，\n 寻找可以代表它执行 \n 进程的 \n。如果没有找到，内核直接执行 \n 本身。那么为什么需要 \n 呢？\n除了设备树之外，在启动时可以提供给内核的另一个文件路径是 \n 的路径。\n 通常位于 \n 目录中，与 x86 系统中的 bzImage 文件 vmlinuz 一样，或是与 ARM 系统中的 uImage 和设备树相同。用 \n 软件包中的 \n 工具可以列出 \n 的内容。发行版的 \n 方案包含了最小化的 \n、\n 和 \n 目录以及内核模块，还有 \n 中的一些文件。所有这些看起来都很熟悉，因为 \n 大致上是一个简单的最小化 Linux 根文件系统。看似相似，其实不然，因为位于虚拟内存盘中的 \n 和 \n 目录下的所有可执行文件几乎都是指向 \n 的符号链接，由此导致 \n 和 \n 目录比 glibc 的小 10 倍。\n如果要做的只是加载一些模块，然后在普通的根文件系统上启动 \n，为什么还要创建一个 \n 呢？想想一个加密的根文件系统，解密可能依赖于加载一个位于根文件系统 \n 的内核模块，当然还有 \n 中的。加密模块可能被静态地编译到内核中，而不是从文件加载，但有多种原因不希望这样做。例如，用模块静态编译内核可能会使其太大而不能适应存储空间，或者静态编译可能会违反软件许可条款。不出所料，存储、网络和人类输入设备（HID）驱动程序也可能存在于 \n 中。\n 基本上包含了任何挂载根文件系统所必需的非内核代码。\n 也是用户存放 \n 表代码的地方。\n 对测试文件系统和数据存储设备也很有用。将这些测试工具存放在 \n 中，并从内存中运行测试，而不是从被测对象中运行。\n最后，当 \n 开始运行时，系统就启动啦！由于第二个处理器现在在运行，机器已经成为我们所熟知和喜爱的异步、可抢占、不可预测和高性能的生物。的确，\n 很容易显示用户空间的 \n 进程已不在引导处理器上运行了。\nLinux 引导过程听起来或许令人生畏，即使是简单嵌入式设备上的软件数量也是如此。但换个角度来看，启动过程相当简单，因为启动中没有抢占、RCU 和竞争条件等扑朔迷离的复杂功能。只关注内核和 PID 1 会忽略了引导程序和辅助处理器为运行内核执行的大量准备工作。虽然内核在 Linux 程序中是独一无二的，但通过一些检查 ELF 文件的工具也可以了解其结构。学习一个正常的启动过程，可以帮助运维人员处理启动的故障。\n要了解更多信息，请参阅 Alison Chaiken 的演讲——\n，已于 1 月 22 日至 26 日在悉尼举行。参见 \n。\n感谢 \n 的提议和指正。\n ", "tags": "IT技术,Linux", "front_image_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg"}
{"url_object_id": "44f879688ac007f05bd74cdf86522e39", "title": "给 “rm” 命令添加个“垃圾桶”", "create_date": "2018/03/11", "url": "http://blog.jobbole.com/113737/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2017/05/77d80105fd15f2465894827e23cc4842.jpeg"], "praise_nums": 1, "fav_nums": 2, "comment_nums": 1, "content": "人类犯错误是因为我们不是一个可编程设备，所以，在使用 \n 命令时要额外注意，不要在任何时候使用 \n。当你使用 \n 命令时，它会永久删除文件，不会像文件管理器那样将这些文件移动到 “垃圾箱”。\n有时我们会将不应该删除的文件删除掉，所以当错误地删除了文件时该怎么办？ 你必须看看恢复工具（Linux 中有很多数据恢复工具），但我们不知道是否能将它百分之百恢复，所以要如何解决这个问题？\n我们最近发表了一篇关于 \n 的文章，在评论部分，我们从用户 Eemil Lgz 那里获得了一个关于 \n 脚本的更新，它可以帮助我们将文件移动到“垃圾箱”而不是永久删除它们。\n将文件移动到“垃圾桶”是一个好主意，当你无意中运行 \n 命令时，可以拯救你；但是很少有人会说这是一个坏习惯，如果你不注意“垃圾桶”，它可能会在一定的时间内被文件和文件夹堆积起来。在这种情况下，我建议你按照你的意愿去做一个定时任务。\n这适用于服务器和桌面两种环境。 如果脚本检测到 GNOME 、KDE、Unity 或 LXDE 桌面环境（DE），则它将文件或文件夹安全地移动到默认垃圾箱 \n，否则会在您的主目录中创建垃圾箱文件夹 \n。\n 脚本托管在 Github 中，可以从仓库中克隆，也可以创建一个名为 \n 的文件并复制其上的代码。\n在 \n 文件中设置别名，\n执行下面的命令使其生效，\n一切就绪，现在你可以执行 \n 命令，自动将文件移动到”垃圾桶”，而不是永久删除它们。\n测试一下，我们将删除一个名为 \n 的文件，命令行明确的提醒了 \n。\n也可以通过 \n 命令或 \n 进行验证。\n或者我们可以通过文件管理器界面中查看相同的内容。\n（LCTT 译注：原文此处混淆了部分 trash-cli 的内容，考虑到文章衔接和逻辑，此处略。）\n要了解 \n 的其他选项，请查看帮助。\n ", "tags": "IT技术,Linux", "front_image_path": "full/d1b17b98748a74826464a08e6d30a4ee1b15b171.jpg"}
{"url_object_id": "c04253a00ce7d51d704df4838a462dc1", "title": "工程师思维，做不出好产品？", "create_date": "2018/03/19", "url": "http://blog.jobbole.com/112125/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2017/07/15cdc9eaec6ba9ac858b0eaebfb6b949.jpg"], "praise_nums": 1, "fav_nums": 0, "comment_nums": 2, "content": "这不是一个鸡汤文，也不是警世文，这文章没什么结论和重点，你不会从这篇文章中获得什么领悟。\n恭喜你，你选择继续往下看，代表你对这标题也有一定程度的好奇，或许你也有同样的疑惑？\n「你的想法太工程师了，不适用在「一般」用户上，怎么可能用一般用户的角度去思考产品呢？」会这样说可能是你就是从事市场或和技术半毛关系都没有的岗位上。\n我觉得这个指控实在很莫名其妙，农夫讲出关于种树的话，渔夫讲出关于捞鱼的话，本该是天经地义的事，然后现在我们要进森林开垦，凭什么渔夫说的就是道理，农夫说的就是歪理呢。\n况且重点还是，最后要操刀的是农夫啊！\n世间上的事，都不是完全都是两极化的对与错，一件事通常面向都会超过一个，就取决于那是站在那一面观看，我要说的正是，软件工程师如何设计好产品。\n马云说过一句差不多这样的话，他说：他就是 QA，他不会用的产品，大概就不是什么好产品，因为大部分人都和他一样，是一个不懂技术的人。\n就单凭这句话，很多人就会抛开技术思维，抛开一切，就只想自己要做的「大方向」就好，那是当然的，做为一个领导，作为一艘船的导航，确实需要一个明确的方向，大家就尽力前进。但前进的动力来自哪里呢？你可以知道人家背后有多少水手不断研究划船的方法，才可以说出这句那么铿锵有力的话。\n「我考第一名，我从来不念书！」\n马云那番话字面上理解，那个思维是成立的，但事实上，越是简单的产品，RD 就必须花更多的时间和精力去思考，如果做出「简单」而产品的「直觉和简单」仅仅只是技术演进的结果罢了，千万不要忽略过程。\n我只想要飞，就往断崖跳，就肯定会死的。想要飞的心情我理解，但我们能不能坐下来谈谈如何办到「飞」这回事呢？\n而越简单的东西，越难做出来。\n有一个箱子，里面很冷，食物不会坏；一个箱子，里面有画面，哎！箱子好占空间，做到跟墙一样薄行不行？我想要一个放在口袋的电脑，看到的脸就开锁，啊，要确保一定会开喔，不要让我 demo 的时候开不了。\n概念谁都会说，根本不需要花很多时间在这个地方上。\n一个好产品，重点是要解决问题，是不是废话？是。\n那么要解决问题，要靠技术？还是靠想法？…\n你开始质疑自己了吧，你没有马上选技术，或者你选了想法？\n因为一般人是不会有这个认知的。你不用怀疑，好产品解决问题的重点，就是技术。不是想法。这两者有什么区别？会讲不会做，就叫做想法；会讲也会做，那是技术。但产品人员最爱放在嘴巴的一句话就是「技术不难，可以做得出来」、「技术可以办到」大部分的概念都是来自于别家产品，至于如何实现，还是一种跟网恋一样的概念，还没见过本人，但是照片看起来还不错。\n时至今日要找出，只要好点子，就有好活路的故事太少了，技术突破不了，就是一个「和别人差不多」的东西。既然是差不多，就没有必要多一个，面对消费者，你要怎么说服人家用你家的产品呢？\n我写了一大堆都是在靠北，没什么重点，那我先讲一个重点。\n「讲 HOW 不要讲 WHAT 和 WHY」\n一个组织要做什么事，应该不难决定，那就是一个决定。\n试想想，最近我有个朋友在想开餐厅的事，我就默默的观察，他会如何思考开餐厅的流程。\n他从菜单一路讲到店面，从行销和定位，说到 SWOT 和五力分析。都还没说到，如何做饭这个点上。虽然只是比喻，但是你可以想像餐厅本身最关键的除了价格，就是味道，好吃！最直接的竞争力，就是要\n「HOW 做到很好吃」一个点就好。\n而 HOW 的精髓，就是技术（技巧），做菜需要技巧；写程序也需要技巧，如何用什么工具解决什么问题（这是重点，我只是没有特别强调）是很重要的一个概念。\n就跟为什么这个控肉饭那么好吃，它是怎么办到的？！靠，那就是靠技术啊，每天做研究啊，研究又试做啊，然后失败又再来啊，不然你以为咧。\n至于说，技术本身是没有意义的，除非它用来解决问题。\n那就是一个重点了，要讲出问题在哪里（WHAT），和为什么会发生（WHY），即便这些很有可能都是在猜的，要讲出几个点那也不是一件难的差事，只差你愿不愿意面对而已，因为就算你说错了，也没有什么证据证明你是错的，你顶多只能怀疑，这个家伙在胡说。\n技术本身是没有意义的，就让我想起一个名人说的话，钱本身是没有意义的，除非你利用它！说到我帐户有几万千还没开始「利用」一样。那个重点不是这句话，重点是我没有钱啊！\n技术本身有没有价值，我不好说，但重点是，我们要先研究出技术啊！\n而很多时候，我们只需要一个菜单，就那么简单。但是可怕的事还不是没有菜单，而是有菜单还有一叠厚厚的明细，随着不懂做菜的人进厨房，然后还帮你为每个做菜步骤列名时间和顺序，然后当你仔细一看，那个根本不是做菜步骤，是上菜和吃饭的步骤，里面写的跟做菜一点屁关系都没有。\n这群人根本不在乎怎么做菜啊。\n但不要误会，半点也没有怪他们「为何不关心」做菜这事上。\n因为很多时候，甚至极大部分时候，工程师也是不关心如何「上菜」的，也不关心味道如何，只要时间内上菜，老板没有埋怨，客户没有中毒死，更也别说口碑好不好，有的厨师本来就是抱着能吃就好的心情做菜，竟然吃不死，就是好料理啦。\n但这主题是说「好产品」就不是能吃就好的东西了，要对味道和整个用餐过程都很有要求。\n就算不是五星，也要老板亲切啊，服务态度 UX 要好，UX 不是一个人的工作，UX 是一个团队的工作，一个集体带来的效益。大部分团队就是设计出图，PM 画 flow，RD 写 code；就跟打传说有人坦克，有人输出，有人牵制，但如果要胜出，就可能互相帮打，坦克输出会补刀，输出火力也要帮忙牵制，但是如果规定了坦克就只能挨打，牵制就只能在那边躲起来发功，那就死定了。\n分工的结果就如参加一个比赛，的确是顺利的把比赛结束了，但也别想说有什么惊喜的表现。\n写程序的人就会用工具了，尤其是前端，现在光是设一个开发环境，就用了一堆东西，有些太久没有用它还更新改版了，有天有个朋友请我帮忙做个事，我就拿着笔电狂 Key，滴滴答答的，一个多小时之后，我就「yeah」喊了一声，他就问「你弄好咯，感谢啦」\n我说「还没，但可以开始弄了！yeah」\n但我以一个消费者的立场，做出产品，至于好不好，是消费者自己的看法。千万不要一直和我说你东西有多好吃，我自己有嘴巴好嘛！如果不好吃，你和我说一百遍也不会好吃啊。", "tags": "职场,工程师", "front_image_path": "full/d6573fc92df4aa98014ce9dc55320411b7b5bf1d.jpg"}
{"url_object_id": "2796ee392f681a8f36e227ce37a3b069", "title": "邪恶的编程咒语", "create_date": "2018/03/12", "url": "http://blog.jobbole.com/113631/", "front_image_url": ["http://wx3.sinaimg.cn/large/7cc829d3gy1fo80ho6bhuj20fu09twfy.jpg"], "praise_nums": 2, "fav_nums": 4, "comment_nums": 2, "content": "自从我看了 Gary Bernhardt 备受推崇的一个视频 \n，就惊异于特定编程语言的怪异行为。相较于其他编程语言来说，某些编程语言的行为更出乎意料。例如，有\n是针对 Java 的边缘案例和古怪情况。同样，差不多只要 200 美元你就可以阅读 \n了。\n下面是我最喜欢的、惊奇的、滑稽的并仍然有效的咒语集合。一般来讲，利用这些古怪的行为被视为\n，因为代码不应该出乎意料。值得庆幸的是，如果你尝试以下大多数蠢事，有很多代码校检工具（linters）已经准备好嘲笑你了。说了这么多，知识就是力量，那就开始吧。\n谢天谢地，这在 Python 3 中会导致 \n，因为\n。它仍远没有 C++ 的那个恶作剧那么邪恶，把 \n 悄悄写进同事的开发机器的标准头文件中。\n对 Java 新手程序员来说，\n 的语义往往使人困惑。甚至在微不足道的情境下，这个操作符的前后矛盾也会使情况变得复杂，即使性能效益是值得的。\nJVM 会对区间 [-128, 127] 内的值使用相同的引用。更奇怪的是，Python 中也有同样的行为。\n目前为止，还没有特别出乎意料的。\n似乎 python 解释器使用相同例子的下限是……-5。区间 [-5, 256] 内的整数有同样的 ID。不知怎地，这变得更奇怪了。\n似乎使用解构赋值改变了这里的规则。我不确定为什么是这样。事实上，我在 \n来试着理解它。我的猜测是，一个列表中的重复值指向同一个对象，用以节省内存。\n颠倒的下标符号，会使所有开发者都头疼。\n这行得通的原因是，\n 确实只是 \n 的语法糖。由于加法的交换性，我们可以交换数组和索引，并得到同样的结果。\n 操作符第一次被看到时，似乎是句法错误。在你意识到它可编译时，它看起来像未被记载的语言特性。幸运的是，两者都不是。\n “操作符”实际上是两个操作符，在这个背景下解析为\n。众所周知，大量使用会导致困惑，这完全是邪恶的。\n 操作符是一个编译时操作符，这给予了它有趣的属性。\n由于 \n 操作符的例子是对编译时进行评估的，\n不会运行。另一件趣事是，研究表明 \n 是最普遍的没有被 push 的代码。\n 一直在用“\n \n \n \n”表情包取乐。令人震惊的是，有大量编程语言使用从 1 开始的数组索引。可以在\n找到更全面的清单。\n… and only Ruby. *\n在 Ruby 中是这样。*\n* edit: It was pointed out on \n that this is true for Lua, Lisp, and Erlang as well.\n* 修订：Reddit 上有人指出，这在 Lua、Lisp 和 Erlang 中也成立。\nTrigraph, Digraphs, and Tokens in C\n由于历史原因，C 语言中的非字母符号有替代品。\n有些外国设备，例如 IBM 3270，在 C/C++ 中不提供某些常用符号，所以提供了 digraph、trigraph 和 token 来避免排斥特定字符集。", "tags": "开发,编程语言", "front_image_path": "full/280c8276f25da11c38fa166860dc2754091de28f.jpg"}
{"url_object_id": "1c7d5802b140adefb9805592b6a7e332", "title": "在 Linux 中自动配置 IPv6 地址", "create_date": "2018/03/14", "url": "http://blog.jobbole.com/113771/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "praise_nums": 1, "fav_nums": 2, "comment_nums": 1, "content": "在 \n 一文中，我们学习了关于唯一本地地址unique local addresses（ULA）的相关内容。在本文中，我们将学习如何为 ULA 自动配置 IP 地址。\n唯一本地地址unique local addresses（ULA）使用 \n 地址块，它类似于我们常用的 IPv4 的私有地址：\n、\n、以及 \n。但它们并不能直接替换。IPv4 的私有地址分类和网络地址转换（NAT）功能是为了缓解 IPv4 地址短缺的问题，这是个明智的解决方案，它延缓了本该被替换的 IPv4 的生命周期。IPv6 也支持 NAT，但是我想不出使用它的理由。IPv6 的地址数量远远大于 IPv4；它是不一样的，因此需要做不一样的事情。\n那么，ULA 存在的意义是什么呢？尤其是在我们已经有了本地链路地址link-local addresses（\n）时，到底需不需要我们去配置它们呢？它们之间（LCTT 译注：指的是唯一本地地址和本地链路地址）有两个重要的区别。一是，本地链路地址是不可路由的，因此，你不能跨子网使用它。二是，ULA 是你自己管理的；你可以自己选择它用于子网的地址范围，并且它们是可路由的。\n使用 ULA 的另一个好处是，如果你只是在局域网中“混日子”的话，你不需要为它们分配全局单播 IPv6 地址。当然了，如果你的 ISP 已经为你分配了 IPv6 的全局单播地址global unicast addresses，就不需要使用 ULA 了。你也可以在同一个网络中混合使用全局单播地址和 ULA，但是，我想不出这样使用的一个好理由，并且要一定确保你不使用网络地址转换（NAT）以使 ULA 可公共访问。在我看来，这是很愚蠢的行为。\nULA 是仅为私有网络使用的，并且应该阻止其流出你的网络，不允许进入因特网。这很简单，在你的边界设备上只要阻止整个 \n 范围的 IPv6 地址即可实现。\nULA 不像本地链路地址那样自动配置的，但是使用 radvd 设置自动配置是非常容易的，radva 是路由器公告守护程序。在你开始之前，运行 \n 或者 \n 去查看你现有的 IP 地址。\n在生产系统上使用时，你应该将 radvd 安装在一台单独的路由器上，如果只是测试使用，你可以将它安装在你的网络中的任意 Linux PC 上。在我的小型 KVM 测试实验室中，我使用 \n 命令把它安装在 Ubuntu 上。安装完成之后，我先不启动它，因为它还没有配置文件：\n这些所有的消息有点让人困惑，实际上 radvd 并没有运行，你可以使用经典命令 \n 来验证这一点。因此，我们现在需要去创建 \n 文件。拷贝这个示例，将第一行的网络接口名替换成你自己的接口名字：\n前缀（\n）定义了你的网络地址，它是地址的前 64 位。前两个字符必须是 \n，前缀接下来的剩余部分你自己定义它，最后的 64 位留空，因为 radvd 将去分配最后的 64 位。前缀后面的 16 位用来定义子网，剩余的地址定义为主机地址。你的子网必须总是 \n。RFC 4193 要求地址必须随机生成；查看 \n 学习创建和管理 ULAs 的更多知识。\nIPv6 转发必须要启用。下面的命令去启用它，重启后生效：\n取消注释或者添加如下的行到 \n 文件中，以使它永久生效：\n启动 radvd 守护程序：\n这个示例在我的 Ubuntu 测试系统中遇到了一个怪事；radvd 总是停止，我查看它的状态却没有任何问题，做任何改变之后都需要重新启动 radvd。\n启动成功后没有任何输出，并且失败也是如此，因此，需要运行 \n 去查看它的运行状态。如果有错误，\n 会告诉你。一般常见的错误都是 \n 中的语法错误。\n在 Twitter 上抱怨了上述问题之后，我学到了一件很酷的技巧：当你运行 \n 去调试 \n 错误时，你的输出会被换行，然后，你就可以看到错误信息。\n现在检查你的主机，查看它们自动分配的新地址：\n本文到此为止，下周继续学习如何为 ULA 管理 DNS，这样你就可以使用一个合适的主机名来代替这些长长的 IPv6 地址。\n通过来自 Linux 基金会和 edX 的 \n 免费课程学习更多 Linux 的知识。\n ", "tags": "IT技术,IPv6,Linux", "front_image_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg"}
{"url_object_id": "b49b820d1a88139adbc0e923d2f824f6", "title": "Linux 跟踪器之选", "create_date": "2018/03/10", "url": "http://blog.jobbole.com/113735/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2018/01/1b8322e1daff605d71fc81e724421f17.jpg"], "praise_nums": 1, "fav_nums": 2, "comment_nums": "  评论", "content": "跟踪器tracer是一个高级的性能分析和调试工具，如果你使用过 \n 或者 \n，你不应该被它吓到 … 你使用的就是跟踪器。系统跟踪器能让你看到很多的东西，而不仅是系统调用或者数据包，因为常见的跟踪器都可以跟踪内核或者应用程序的任何东西。\n有大量的 Linux 跟踪器可供你选择。由于它们中的每个都有一个官方的（或者非官方的）的吉祥物，我们有足够多的选择给孩子们展示。\n你喜欢使用哪一个呢？\n我从两类读者的角度来回答这个问题：大多数人和性能/内核工程师。当然，随着时间的推移，这也可能会发生变化，因此，我需要及时去更新本文内容，或许是每年一次，或者更频繁。（LCTT 译注：本文最后更新于 2015 年）\n大多数人（开发者、系统管理员、运维人员、网络可靠性工程师（SRE）…）是不需要去学习系统跟踪器的底层细节的。以下是你需要去了解和做的事情：\n可以使用 perf_events 进行 CPU 剖析profiling。它可以用一个 \n 来形象地表示。比如：\nLinux 的 perf_events（即 \n，后者是它的命令）是官方为 Linux 用户准备的跟踪器/分析器。它位于内核源码中，并且维护的非常好（而且现在它的功能还在快速变强）。它一般是通过 linux-tools-common 这个包来添加的。\n 可以做的事情很多，但是，如果我只能建议你学习其中的一个功能的话，那就是 CPU 剖析。虽然从技术角度来说，这并不是事件“跟踪”，而是采样sampling。最难的部分是获得完整的栈和符号，这部分在我的 \n 中针对 Java 和 Node.js 讨论过。\n正如一位朋友所说的：“你不需要知道 X 光机是如何工作的，但你需要明白的是，如果你吞下了一个硬币，X 光机是你的一个选择！”你需要知道使用跟踪器能够做什么，因此，如果你在业务上确实需要它，你可以以后再去学习它，或者请会使用它的人来做。\n简单地说：几乎任何事情都可以通过跟踪来了解它。内部文件系统、TCP/IP 处理过程、设备驱动、应用程序内部情况。阅读我在 lwn.net 上的 \n 的文章，也可以去浏览 \n，那里有一些跟踪（和剖析）能力的示例。\n如果你要购买一个性能分析工具（有许多公司销售这类产品），并要求支持 Linux 跟踪。想要一个直观的“点击”界面去探查内核的内部，以及包含一个在不同堆栈位置的延迟热力图。就像我在 \n 中描述的那样。\n我创建并开源了我自己的一些前端工具，虽然它是基于 CLI 的（不是图形界面的）。这样可以使其它人使用跟踪器更快更容易。比如，我的 \n，跟踪新进程是这样的：\n在 Netflix 公司，我正在开发 \n，它是一个实例分析工具，实际上它也是一个 Linux 跟踪器的前端。\n一般来说，我们的工作都非常难，因为大多数人或许要求我们去搞清楚如何去跟踪某个事件，以及因此需要选择使用哪个跟踪器。为完全理解一个跟踪器，你通常需要花至少一百多个小时去使用它。理解所有的 Linux 跟踪器并能在它们之间做出正确的选择是件很难的事情。（我或许是唯一接近完成这件事的人）\n在这里我建议选择如下，要么：\nA）选择一个全能的跟踪器，并以它为标准。这需要在一个测试环境中花大量的时间来搞清楚它的细微差别和安全性。我现在的建议是 SystemTap 的最新版本（例如，从 \n 构建）。我知道有的公司选择的是 LTTng ，尽管它并不是很强大（但是它很安全），但他们也用的很好。如果在 \n 中添加了跟踪点或者是 kprobes，它也是另外的一个候选者。\nB）按我的 \n 的流程图。这意味着尽可能使用 ftrace 或者 perf_events，eBPF 已经集成到内核中了，然后用其它的跟踪器，如 SystemTap/LTTng 作为对 eBPF 的补充。我目前在 Netflix 的工作中就是这么做的。\n以下是我对各个跟踪器的评价：\n我爱 \n，它是内核黑客最好的朋友。它被构建进内核中，它能够利用跟踪点、kprobes、以及 uprobes，以提供一些功能：使用可选的过滤器和参数进行事件跟踪；事件计数和计时，内核概览；函数流步进function-flow walking。关于它的示例可以查看内核源代码树中的 \n。它通过 \n 来管理，是面向单一的 root 用户的（虽然你可以使用缓冲实例以让其支持多用户），它的界面有时很繁琐，但是它比较容易调校hackable，并且有个前端：ftrace 的主要创建者 Steven Rostedt 设计了一个 trace-cmd，而且我也创建了 perf-tools 集合。我最诟病的就是它不是可编程的programmable，因此，举个例子说，你不能保存和获取时间戳、计算延迟，以及将其保存为直方图。你需要转储事件到用户级以便于进行后期处理，这需要花费一些成本。它也许可以通过 eBPF 实现可编程。\n 是 Linux 用户的主要跟踪工具，它的源代码位于 Linux 内核中，一般是通过 linux-tools-common 包来添加的。它又称为 \n，后者指的是它的前端，它相当高效（动态缓存），一般用于跟踪并转储到一个文件中（perf.data），然后可以在之后进行后期处理。它可以做大部分 ftrace 能做的事情。它不能进行函数流步进，并且不太容易调校（而它的安全/错误检查做的更好一些）。但它可以做剖析（采样）、CPU 性能计数、用户级的栈转换、以及使用本地变量利用调试信息debuginfo进行行级跟踪line tracing。它也支持多个并发用户。与 ftrace 一样，它也不是内核可编程的，除非 eBPF 支持（补丁已经在计划中）。如果只学习一个跟踪器，我建议大家去学习 perf，它可以解决大量的问题，并且它也相当安全。\n扩展的伯克利包过滤器extended Berkeley Packet Filter（eBPF）是一个内核内in-kernel的虚拟机，可以在事件上运行程序，它非常高效（JIT）。它可能最终为 ftrace 和 perf_events 提供内核内编程in-kernel programming，并可以去增强其它跟踪器。它现在是由 Alexei Starovoitov 开发的，还没有实现完全的整合，但是对于一些令人印象深刻的工具，有些内核版本（比如，4.1）已经支持了：比如，块设备 I/O 的延迟热力图latency heat map。更多参考资料，请查阅 Alexei 的 \n，和它的 \n。\n 是一个非常强大的跟踪器。它可以做任何事情：剖析、跟踪点、kprobes、uprobes（它就来自 SystemTap）、USDT、内核内编程等等。它将程序编译成内核模块并加载它们 —— 这是一种很难保证安全的方法。它开发是在内核代码树之外进行的，并且在过去出现过很多问题（内核崩溃或冻结）。许多并不是 SystemTap 的过错 —— 它通常是首次对内核使用某些跟踪功能，并率先遇到 bug。最新版本的 SystemTap 是非常好的（你需要从它的源代码编译），但是，许多人仍然没有从早期版本的问题阴影中走出来。如果你想去使用它，花一些时间去测试环境，然后，在 irc.freenode.net 的 #systemtap 频道与开发者进行讨论。（Netflix 有一个容错架构，我们使用了 SystemTap，但是我们或许比起你来说，更少担心它的安全性）我最诟病的事情是，它似乎假设你有办法得到内核调试信息，而我并没有这些信息。没有它我实际上可以做很多事情，但是缺少相关的文档和示例（我现在自己开始帮着做这些了）。\n 对事件收集进行了优化，性能要好于其它的跟踪器，也支持许多的事件类型，包括 USDT。它的开发是在内核代码树之外进行的。它的核心部分非常简单：通过一个很小的固定指令集写入事件到跟踪缓冲区。这样让它既安全又快速。缺点是做内核内编程不太容易。我觉得那不是个大问题，由于它优化的很好，可以充分的扩展，尽管需要后期处理。它也探索了一种不同的分析技术。很多的“黑匣子”记录了所有感兴趣的事件，以便可以在 GUI 中以后分析它。我担心该记录会错失之前没有预料的事件，我真的需要花一些时间去看看它在实践中是如何工作的。这个跟踪器上我花的时间最少（没有特别的原因）。\n 是一个很有前途的跟踪器，它在内核中使用了一个 lua 虚拟机，不需要调试信息和在嵌入时设备上可以工作的很好。这使得它进入了人们的视野，在某个时候似乎要成为 Linux 上最好的跟踪器。然而，由于 eBPF 开始集成到了内核，而 ktap 的集成工作被推迟了，直到它能够使用 eBPF 而不是它自己的虚拟机。由于 eBPF 在几个月过去之后仍然在集成过程中，ktap 的开发者已经等待了很长的时间。我希望在今年的晚些时间它能够重启开发。\n 主要由一个人（Paul Fox）利用业务时间将 Sun DTrace 移植到 Linux 中的。它令人印象深刻，一些供应器provider可以工作，还不是很完美，它最多应该算是实验性的工具（不安全）。我认为对于许可证的担心，使人们对它保持谨慎：它可能永远也进入不了 Linux 内核，因为 Sun 是基于 CDDL 许可证发布的 DTrace；Paul 的方法是将它作为一个插件。我非常希望看到 Linux 上的 DTrace，并且希望这个项目能够完成，我想我加入 Netflix 时将花一些时间来帮它完成。但是，我一直在使用内置的跟踪器 ftrace 和 perf_events。\n 是将 DTrace 移植到 Linux （尤其是 Oracle Linux）的重大努力。过去这些年的许多发布版本都一直稳定的进步，开发者甚至谈到了改善 DTrace 测试套件，这显示出这个项目很有前途。许多有用的功能已经完成：系统调用、剖析、sdt、proc、sched、以及 USDT。我一直在等待着 fbt（函数边界跟踪，对内核的动态跟踪），它将成为 Linux 内核上非常强大的功能。它最终能否成功取决于能否吸引足够多的人去使用 Oracle Linux（并为支持付费）。另一个羁绊是它并非完全开源的：内核组件是开源的，但用户级代码我没有看到。\n 是一个很新的跟踪器，它可以使用类似 \n 的语法来处理系统调用syscall事件，并用 lua 做后期处理。它也是令人印象深刻的，并且很高兴能看到在系统跟踪领域的创新。它的局限性是，它的系统调用只能是在当时，并且，它转储所有事件到用户级进行后期处理。你可以使用系统调用来做许多事情，虽然我希望能看到它去支持跟踪点、kprobes、以及 uprobes。我也希望看到它支持 eBPF 以查看内核内概览。sysdig 的开发者现在正在增加对容器的支持。可以关注它的进一步发展。\n我自己的工作中使用到的跟踪器包括：\n不好意思，没有更多的跟踪器了！ … 如果你想知道为什么 Linux 中的跟踪器不止一个，或者关于 DTrace 的内容，在我的 \n 的演讲中有答案，从 \n 开始。\n感谢 \n 的编辑，以及跟踪小马的创建（General Zoi 是小马的创建者）。\n ", "tags": "IT技术,Linux", "front_image_path": "full/14452eea6b79bce0219227f298ad827f2ba7112d.jpg"}
{"url_object_id": "aa94da9060b646e6772ebf4ad4c5ffe7", "title": "开源作者遭受小白的 9 种伤害", "create_date": "2018/03/09", "url": "http://blog.jobbole.com/113728/", "front_image_url": ["http://jbcdn2.b0.upaiyun.com/2017/09/f1a3d556b79a7fae23ad3ecc6f972164.jpg"], "praise_nums": 2, "fav_nums": 2, "comment_nums": 2, "content": "", "tags": "业界,开源", "front_image_path": "full/70c7b887c37d9154dc2b5636ed919464c716d375.jpg"}
